<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>（转载）cpp算法模板 | arctanp</title><meta name="keywords" content="算法"><meta name="author" content="Tanpinsary"><meta name="copyright" content="Tanpinsary"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="（转载）cpp算法模板"><meta name="application-name" content="（转载）cpp算法模板"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="（转载）cpp算法模板"><meta property="og:url" content="http://blog.arctanp.top/2025/03/21/（转载）cpp算法模板/index.html"><meta property="og:site_name" content="arctanp"><meta property="og:description" content="C++算法模板基础算法排序快速排序1234567891011void quickSort(int q[], int l, int r) &amp;#123;    if (l &amp;gt;&amp;#x3D; r) return;    int i &amp;#x3D; l - 1, j &amp;#x3D; r + 1, x &amp;#x3D; q[l + r &amp;gt;&amp;gt;"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://pic.arctanp.top/PicGo/1742042046711.jpeg?_r_=0fe43d33-1d26-f270-676a-a3edd0e011f3"><meta property="article:author" content="Tanpinsary"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic.arctanp.top/PicGo/1742042046711.jpeg?_r_=0fe43d33-1d26-f270-676a-a3edd0e011f3"><meta name="description" content="C++算法模板基础算法排序快速排序1234567891011void quickSort(int q[], int l, int r) &amp;#123;    if (l &amp;gt;&amp;#x3D; r) return;    int i &amp;#x3D; l - 1, j &amp;#x3D; r + 1, x &amp;#x3D; q[l + r &amp;gt;&amp;gt;"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://blog.arctanp.top/2025/03/21/%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89cpp%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"tanp","mode":"local","switchBtn":true,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: undefined,
  LA51: undefined,
  greetingBox: {"enable":true,"default":"喜欢视奸？","list":[{"greeting":"夜","startTime":0,"endTime":4},{"greeting":"4点了 该坠机了","startTime":4,"endTime":4},{"greeting":"tanp大概率在睡觉","startTime":5,"endTime":10},{"greeting":"呜噜呜噜摸了","startTime":10,"endTime":18},{"greeting":"该饭了","startTime":18,"endTime":19},{"greeting":"夜","startTime":19,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: {"skills":["最大的技能就是还活着"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Tanpinsary","link":"链接: ","source":"来源: arctanp","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'arctanp',
  title: '（转载）cpp算法模板',
  postAI: '',
  pageFillDescription: 'C++算法模板, 基础算法, 排序, 快速排序, 归并排序, 二分, 整数二分, 浮点数二分, 高精度, 高精度加法, 高精度减法, 高精度乘低精度, 高精度除以低精度, 离散化, 尺取法（双指针）, 数论与数学知识, c++求上取整, 快速幂, 逆元, 费马小定理求逆元, 快速幂求逆元, 线性逆元, 扩展欧几里得算法, 高斯消元法, 筛质数, 朴素筛法, 质数定理, 埃氏筛法, 线性筛法, 欧拉函数, 筛法求欧拉函数, 组合数, 组合数1, 组合数2, 博弈论, SG函数, 图论, 最短路, Dijkstra求最短路(朴素版), 堆优化的Dijkstra算法, SPFA, 最小生成树, kruskal算法, LCA(最近公共祖先), dfs版本预处理, 欧拉路径与欧拉回路, dfs, fleury, 数据结构, 链表, 单链表（静态）, 双链表, 队列, 一般队列, 循环队列, 单调队列, 栈, 一般栈, 表达式求值, 单调栈, KMP, TRIE, 堆, 并查集, 哈希表, 模拟, 拉链法, 开放寻址法, 树状数组和线段树, 树状数组, 线段树, 树链剖分（重链剖分）, 树上启发式合并, 莫队, 基础莫队, 玄学优化, 对顶堆, 双set版本, 堆带删除操作版, 堆仅插入版, 主席树（可持久化权值线段树）, 动态规划, 最长上升子序列, 背包问题, 01背包, 01背包问题的二维代码, 01背包一维优化, 完全背包问题, 完全背包问题的三重循环代码, 二重循环二维的优化过程, 完全背包一维最终优化, 多重背包1, 多重背包问题的三重循环代码, 多重背包问题一维优化代码, 多重背包问题打包版, 多重背包单调队列优化, 分组背包问题, 分组背包问题一维优化代码, 背包问题中总体积最多x2F恰好x2F最少为j 以求最大值为例(3是最小值), 有依赖的背包问题, 混合背包问题, 随机算法, 模拟退火, 计算几何, 前置知识算法模板基础算法排序快速排序归并排序二分整数二分检查是否满足某种性质区间被划分成和时使用判断是否满足性质区间被划分成和时使用浮点数二分检查是否满足某种性质表示精度取决于题目对精度的要求高精度高精度加法高精度减法满足高精度乘低精度高精度除以低精度离散化存储所有待离散化的值将所有值排序去掉重复元素二分求出对应的离散化的值尺取法双指针具体问题的逻辑常见问题分类对于一个序列用两个指针维护一段区间对于两个序列维护某种次序比如归并排序中合并两个有序序列的操作数论与数学知识求上取整快速幂不可写成逆元费马小定理求逆元费马小定理是数论中的一个重要定理在年提出如果是一个质数而整数不是的倍数则有对上式变形得则的逆元是接下来通过即可求出的逆元快速幂求逆元基于费马小定理求的逆元要求是是一个质数并且与互质线性逆元证明线性求解个数字的逆元需要找到新元素的逆元同以往求解过逆元的关系以下面式子举例对于要求解逆元的模数为有进而有两边同时乘以得到即我们知道因此有求解个不同数字的逆元求解个不同数字的逆元可以先维护一个前缀积其最后一项是所有数字的乘积求该项的逆元即求所有项逆元的乘积由于逆元的特殊性质逆元的乘积乘上其中某个元素即会消去对应的元素因此我们可以借助前缀积来逐个迭代处理出所有数字的逆元或且有于是便可以处理处所有元素的逆元扩展欧几里得算法扩展欧几里得算法求使得始终都是和的最大公约数倒着传参是为了简化计算返回使得能够在求最大公约数的同时完成的凑整高斯消元法代表有无穷多组解代表无解代表有唯一组解筛质数朴素筛法时间复杂度分析每个数的倍数都被筛掉了因此时间复杂度为其中是一个欧拉常数是一个无限不循环小数值是左右质数定理中有个质数我们可以只用把质数的倍数删掉这样粗劣的时间复杂度就是但是这只是个粗略的估计这个估计是不对的真实的时间复杂度是这个算法也就是下面的埃氏筛法埃氏筛法线性筛法线性筛法在次方的情况下会比埃氏筛法快一倍左右在的情况下两个算法速度差不多整体思路只会被它的最小质因子筛掉即即当还没有执行到下面的语句时由于我们是从小到大枚举所有质数的且还没有枚举到的最小质因子所以当前的一定是的最小质因子所以就把筛掉当这段代码执行的时候就意味着一定是的最小质因子是从小到大枚举的质数当第一次满足的时候说明就一定是的最小质因子同时此时也一定是的最小质因子因此上面的筛成立当如果此时再继续向后枚举质数接下来的质数就不是的最小质因子了因此要即时掉证明线性对于一个合数假设是的最小质因子当枚举到的时候我们就可以在到行把给筛掉第五行的判断条件不需要加因为当是合数的时候一定会在枚举到的最小质因子时停下来而的最小质因子一定是小于的会在之前被标记为放到数组中来当是质数的时候当的时候枚举也会停下来是在的时候停下来欧拉函数中和互质的数的个数一个数可以写成很多个质数的乘积的形式上式的证明会用到容斥原理那么如何计算从中和互质的数的个数呢从中去掉的所有倍数这里面就会多去一部分数比如一个数可能既是的倍数又是的倍数加上所有的倍数减去所有三个质数的倍数然后把最上面的式子展开会发现这两个式子是相等的时间复杂度时间复杂度瓶颈在分解质因数上分解质因数的时间复杂度是代码筛法求欧拉函数此时是的最小质因子的质因子中有了所以的所有的质因子都在中计算过了因此两者的区别就只有式子开头的所以这里就是组合数组合数主要思想时间复杂度组合数预处理阶乘存的分别是的阶乘及其逆元求这里要及时取模否则会爆博弈论必胜态从这个状态总是有某种方式走到一个必败态必败态从这个状态无论怎么走都是会走到必胜态如果先手初始处于必败态那么先手必败反之先手必胜函数首先我们定义一个函数或者称为操作返回集合中未曾出现过的最小的自然数如果处于最终态则返回否则返回该节点可以到达的状态集合中未曾出现过的最小的自然数图论最短路求最短路朴素版算法总体流程不在中的距离最近的点其中表示当前已确定最短距离的点的集合用更新其他点的距离朴素版算法时间复杂度是其中代表图中点的个数因此适合用于稠密图即边多点少的图存储图的值是到的距离因为是稠密图所以用邻接矩阵来存存的是节点到节点的最短距离为说明节点的值是最小距离循环次即更新次这样就把到这个节点的最短路都算出来了找到未存入最短值且到节点距离最短的节点这个优化只有这题能加意思是当求得到的最短路时即可因为这就是题目所求用节点来更新其他节点不是的邻点的话他的就为无穷堆优化的算法堆优化版算法总体流程不在中的距离最近的点其中表示当前已确定最短距离的点的集合用更新其他点的距离堆优化版算法时间复杂度是其中代表图中点的个数代表边的个数因此适合用于稀疏图即边少点多的图因此适合用于稀疏图即边少点多的图因此适合用于稀疏图即边少点多的图算法底子是所有边流程是不空更新的所有出边求最短路不能处理有自环负权和负权环的情况这两种情况会在循环中卡住所以这题数据不太强数组是判断当前节点是否在队列当中防止重复入队循环队列指向队头元素指向队尾元素的后一个元素最小生成树算法路径压缩将边按照权重从小到大排序初始化并查集判断两个节点是否在同一个连通块中将两个连通块合并将边权重累加到结果中记录加入生成树的边的数量判断生成树中是否包含条边无法生成最小生成树输出最小生成树的权重算法是一种贪心算法其正确性可以通过贪心选择性质的证明得到假设我们要构造一个无向连通图的最小生成树我们定义一个边集为好的如果它是某棵最小生成树的子集我们定义一个边集为坏的如果它包含了某个环上的边首先我们考虑一个引理对于任何的连通图为好的则中的边是没有环的证明如果中存在环则我们可以从中删去任意一条边得到一个更小的集合仍然满足好的性质因此在好的边集中所有的边都没有构成环然后我们考虑另一个引理对于任何的连通图令为好的边集合令为一条好的边并令则为某棵生成树的子集证明因为为好的边所以中不包含的时候仍然是连通的因此也是连通的由于中没有环所以它也是无向无环图也就是一棵树此外中有条边与任何生成树的边数相同所以也是某棵生成树的子集有了上面的两个引理我们可以得到算法的正确性证明初始化为空集将所有边按照权值从小到大排序依次考虑每条边如果将其加入不会产生环则将其加入中当加入了条边后停止算法此时即为一棵生成树根据引理中所有的边没有环根据引理算法停止时为某棵生成树的子集根据算法的贪心选择性质我们知道为全局最优的好的边集合因此中的边必定构成了一棵最小生成树因此算法的正确性得证最近公共祖先倍增法求的步骤为把两个点跳到同一层即把下面的跳到和同一层在之后则该点就是和的最近公共祖先即他俩同层但不相同则继续让两个点同时往上跳一直跳到他们的最近公共祖先的下面一层这里跳到最近公共祖先的下一层是因为不这样做的话有可能我们某一次跳过头了跳过了来到了的某一个祖宗节点上这样我们就无法判断在现处节点下面的哪一层上了表示某个节点在树中的深度其中根节点的为越往下深度越大指节点向上走布所能到达的节点的第二个参数是向上走的最大距离取下取整这里是对点数取得通过宽搜来初始化和数组这里起哨兵作用以防跳出根节点之上使尽量跳到和同层并最终一定能跳到版本预处理同时顺便求出每个节点向上对应步数的最小的边权欧拉路径与欧拉回路欧拉路径如果在一张图中可以从一点出发遍历所有的边每条边只能遍历一次那么遍历过程中的这条路径就叫做欧拉路径欧拉回路通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路变形在普通的中我们通常选择对点进行判重但在求欧拉路径的时候因为存在环所以一个点可能被遍历多次因此我们采取对边判重删边优化因为欧拉路径中每条边只走一次因此我们可以在每条边被遍历之后把它删除以节省判重时间达到时间上的优化注意遍历时要写成可以考虑节点有个自环有向边写的话在遍历完三条边回溯的时候接下来要遍历的边都是即遍历结束保证了每条边都被遍历一次且时间是线性的如果写的话则在回溯到第二条边的遍历循环时接下来还是会枚举到即第三条边之后会在第三条边的循环中出来上图即为的遍历顺序可以发现蓝色的边倒序即是欧拉路径注意这里要写成若为无向图则将反向边判重感觉和算法基本一致该算法在有桥的时候时间复杂度为数据结构链表单链表静态是头指针存权值存下一个节点分配节点链表中最后一个节点的始终是在头结点前建立节点双链表节点和节点相当于变相的指针没有值在节点的右边插入值为的节点必须先做这个否则后面的会被修改掉队列一般队列循环队列主要在及算法中使用单调队列以滑动窗口为例代表滑动窗口的长度栈一般栈表达式求值单调栈的值不确定注意数组的定义可能会有多种有些定义下的的值必定是构造数组存储最大公共前后缀从开始默认求的时候已经求出来了此时和对齐回滚到当前前缀串的最大公共前缀串与匹配成功可以匹配下一个位置这里让匹配好的串匹配好的字符数变成匹配存的是所有节点的最大个数每次从根节点开始找标记不是打在要插入的字符串的最后一个字母对应的节点的下一个节点上的堆是用来维护第几个插入堆中的点并查集存储节点的祖宗节点存储节点到祖宗节点的距离初始化找祖宗节点同时更新数组到祖宗的距离到的距离到祖宗的距离这里的距离更新仅仅是更新的正确找祖先的情况下在做并差集合并时还得手动更新哈希表模拟拉链法开放寻址法树状数组和线段树树状数组树状数组的下标从开始不可以从开始因为时会出现死循环这个函数的功能就是求某一个数的二进制表示中最低的一位举个例子它的二进制为那么就返回因为最后一位表示求的和线段树树链剖分重链剖分将树中任意一条路径转化为段连续区间将一棵树转化为一个序列树中路径转化为段连续区间序优先遍历重儿子即可保证重链上所有点的编号是连续的注意这里的是按照优先遍历重儿子来的序定理树中任意一条路径均可拆分成条重链即可拆分成段连续区间重儿子某个节点的所有子树中最大的那个的父节点是当前节点的重儿子其他节点为轻儿子重边重儿子往他的父节点去的边轻边其他所有边重链重边构成的极大的一条链重儿子所在的重链的是他往上的轻儿子轻儿子所在的重链的是他自己预处理出来每个点的重儿子深度所在子数大小算出每个节点的序每个节点所在的重链的顶点是谁树上启发式合并用同一套数组当然也可以是其他数据结构来记录所有子树的信息在更新新的子树信息前把当前子树的信息存下来一般地思考的话我们可以在每次算完当前子树信息将要回溯的时候把数组全部清空但是这样时间复杂度会达到级别因此考虑优化结论每次先算轻儿子为根的子树再算重儿子为根的子树利用重儿子为根的子树的信息来更新当前节点为根的子树的信息并且在算完轻儿子为根的子树的信息后清空信息这样可以把时间复杂度压缩为为什么呢考虑每个节点对答案的贡献次数即搜索次数即这个点所在的所有子树中有多少棵会被遍历由遍历策略导致只有轻儿子为根的子树才会被重复遍历因此贡献次数取决于当前节点所在的子树中有多少棵子树是他父节点的轻儿子换句话来说就是当前节点到根节点的路径中有多少条边是轻边由树链剖分的性质可知最多有条轻边为什么是条轻边呢因为我们从当前点往上走每走一条轻边子树的元素个数至少乘因为上面的父节点会有重儿子且不是当前节点所以最多只能走条轻边代表当前的重儿子即不要重复算重儿子的部分代表是重儿子还是轻儿子莫队基础莫队本质是通过排序优化了普通尺取法的时间复杂度考虑如果某一列询问的右端点是递增的那么我们更新答案的时候右指针只会从左往右移动那么指针的移动次数是的当然我们不可能让左右端点都单调来做到总体考虑对左端点进行分块莫队排序左端点按照分块的编号来排如果分块编号不同的话编号较小的靠前如果相同的话右端点小的在前可以证明这样排完序的话时间复杂度可以做到这样我们把区间分成了块每块的长度都是在每一块内部所有查询的右端点是递增的右指针在每一块内部右端点递增所以右端点走的总数不会超过注意每一块内部放的是左端点右端点是完全有可能超出这个块的范围的因此这里为一共有块所以右端点总共走的次数不会超过左指针先考虑每一次询问左指针在块内部移动块的长度是因此最多只会移动次左指针在相邻两块之间移动最坏是从第一个块的左端点移动到第二个块的右端点因此最坏移动次因为有次询问所以是是因为一共有个块我们从前往后要跨过次每次最多是所以时间复杂度是所以总时间复杂度为玄学优化奇数块块内按照右端点从小到大排偶数快块内按照右端点从大到小排二者可以互换前一段从左到右滚右端点从左滚到了右边接近的位置下一次从右到左滚可以更方便一些相当于更加顺路了如果我们块的大小是的话那么块的数量就是那么的复杂度就是的复杂度是只考虑块内总复杂度为两者之和当两者相等时取得最小值解得代码为统计一段区间上是否有不相同的数没有输出是右指针是左指针对顶堆双版本双用来实现元素的删除操作比优先队列要考虑的细节要少所以一般用双来实现对顶堆因为奇偶对应的中位数位置不一样所以一般要进行奇偶讨论为大根堆为小跟堆我们实现的时候保证两个堆里面的元素个数相同堆的大小始终为偶数其中来维护中位数当当前维护了奇数个元素时对顶堆由共同组成其中代表游离在之外的中位数当当前维护了偶数个元素时对顶堆由共同维护指向两个堆的堆顶之一用来标记当前元素个数是奇数还是偶数个如果是奇数个的话为堆带删除操作版堆仅插入版大根堆小根堆主席树可持久化权值线段树主要适用于解决在线区间第小数问题查询中位数的时候直接取个数较多的堆的堆顶即可动态规划最长上升子序列朴素版本中存的是以结尾的子序列的集合中最长的子序列的长度模拟栈版本模拟堆栈如果该元素大于栈顶元素将该元素入栈替换掉第一个大于或者等于这个数字的那个数二分写法附最长不下降子序列对原数组的每个下标从开始求以结尾的最长不下降子序列长度下标从开始才放如元素是有长度为的子序列的最小的末尾值二分求出以结尾的最长不下降子序列长度背包问题背包状态表示在前个物品中选总体积不超过的最大价值背包问题的二维代码动态规划问题一般下标从开始便于从的情况递推结果背包一维优化完全背包问题特征一个物品可以选无数次状态表示表示从前个物品里选择一个物品可以选多次总体积不超过的最大价值完全背包问题的三重循环代码二重循环二维的优化过程完全三式代入二式得完全背包一维最终优化多重背包特征一个物品有严格的次数限制状态表示表示从前个物品里选择一个物品有严格的次数限制总体积不超过的价值多重背包问题的三重循环代码表示第种物品共有个多重背包问题一维优化代码多重背包问题打包版利用二进制优化的思想把同一种类型的物品按照的不同次幂个为一组进行打包从而优化时间复杂度时间复杂度存储第种物品的个数数组存的是原体积和原价值多重背包单调队列优化时间复杂度是的滚动数组把上一层的存在里滑动窗口长度为不包括本身因此由图中表达式知数组中的值都是不包含的这里我们进行比较只需比较绝对值因此只要营造出递减数列的效果即可分组背包问题特征一组物品只能选择其中的一个状态表示表示从前组物品里选择一组物品最多只能选择其中的一个总体积不超过的最大价值状态计算解释表示从前组物品里选择体积不超过的物品价值的最大值是从要么不选这个物品和要么选择这个组中第个物品的价值之间进行选择分组背包问题一维优化代码代表第组物品中的第个的价值同代表第组物品有多少个背包问题中总体积最多恰好最少为以求最大值为例是最小值体积最多为体积恰好为怎么保证是恰好装满通过初始化来实现如果不存在使满足是恰好装满的那么这个即一个非法答案就不会影响最终的计算体积至少为从前件物品中选总体积至少为的最小价值有依赖的背包问题表示在以为根的子树中选且先选出因为其他节点都依赖这样表示状态会简单一点可以往分组背包其实也不完全是分组背包也就物品组和枚举决策的概念上比较像分组背包上面套总体积不超过的最大价值相当于分组背包问题中的物品组先求一下所有子树中的最大价值故先在最大体积中把当前节点去掉枚举体积枚举决策这里以选取体积为多少讨论决策最后记得把当前节点加上另一种模板表达选择以为子树的物品在容量不超过时所获得的最大价值点必须选所以初始化的范围为小于无法选择以为子树的物品分给子树的空间不能大于不然都无法选根物品混合背包问题由于背包完全背包多重背包的转移方程只和当前的第个物品的类型有关与前面的物品无关所以可以对不同的类型物品独立地使用不同的状态转移方程随机算法模拟退火源自冶金术语将材料加热后再经特定速率冷却的技术目的是增大晶粒体积减少晶格中的缺陷以改变材料的物理性质材料中的原子原来会停留在使内能有局部最小值的位置加热使能量变大原子会离开原来的位置随机在其他位置游走退火冷却时速度较慢使得原子有较多可能可以移动到内能比原先更低的位置为退火温度也即随机范围如果新点距离更小则跳到新点否则以一定概率跳到新点计算几何前置知识前置知识点余弦定理浮点数的比较符号函数比较函数向量向量的加减法和数乘运算内积点积几何意义向量在向量上的投影与的长度的乘积代码实现外积叉积几何意义向量与张成的平行四边形的有向面积在的逆时针方向为正代码实现常用函数取模计算向量夹角计算两个向量构成的平行四边形有向面积向量顺时针旋转的角度点与线直线定理一般式点向式斜截式常用操作判断点在直线上两直线相交则两直线平行或者重合点到直线的距离点到线段的距离点在直线上的投影点是否在线段上判断两线段是否相交多边形三角形面积叉积海伦公式三角形四心外心外接圆圆心三边中垂线交点到三角形三个顶点的距离相等内心内切圆圆心角平分线交点到三边距离相等垂心三条垂线交点重心三条中线交点到三角形三顶点距离的平方和最小的点三角形内到三边距离之积最大的点普通多边形通常按逆时针存储所有点定义多边形由在同一平面且不再同一直线上的多条线段首尾顺次连接且不相交所组成的图形叫多边形简单多边形简单多边形是除相邻边外其它边不相交的多边形凸多边形过多边形的任意一边做一条直线如果其他各个顶点都在这条直线的同侧则把这个多边形叫做凸多边形任意凸多边形外角和均为任意凸多边形内角和为常用函数求多边形面积不一定是凸多边形我们可以从第一个顶点除法把凸多边形分成个三角形然后把面积加起来判断点是否在多边形内不一定是凸多边形射线法从该点任意做一条和所有边都不平行的射线交点个数为偶数则在多边形外为奇数则在多边形内转角法判断点是否在凸多边形内只需判断点是否在所有边的左边逆时针存储多边形皮克定理皮克定理是指一个计算点阵中顶点在格点上的多边形面积公式该公式可以表示为其中表示多边形内部的点数表示多边形边界上的点数表示多边形的面积圆圆与直线交点两圆交点点到圆的切线两圆公切线两圆相交面积作者链接来源',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-21 11:54:23',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://pic.arctanp.top/PicGo/avator"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.arctanp.top" title="博客"><img class="back-menu-item-icon" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://pic.arctanp.top" title="图床"><img class="back-menu-item-icon" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">arctanp</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-link"></use></svg><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2024775299&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lightbulb"></use></svg><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C-C/" style="font-size: 1.05rem;">C/C++<sup>1</sup></a><a href="/tags/acm/" style="font-size: 1.05rem;">acm<sup>1</sup></a><a href="/tags/deepseek-r1/" style="font-size: 1.05rem;">deepseek-r1<sup>1</sup></a><a href="/tags/insights/" style="font-size: 1.05rem;">insights<sup>1</sup></a><a href="/tags/llm/" style="font-size: 1.05rem;">llm<sup>1</sup></a><a href="/tags/markdown/" style="font-size: 1.05rem;">markdown<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">复习笔记<sup>3</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">学习笔记<sup>4</sup></a><a href="/tags/%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">实践笔记<sup>1</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/" style="font-size: 1.05rem;">数学分析<sup>2</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 1.05rem;">测试<sup>1</sup></a><a href="/tags/%E7%89%A9%E7%90%86/" style="font-size: 1.05rem;">物理<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>3</sup></a><a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 1.05rem;">语法<sup>1</sup></a><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 1.05rem;">随笔<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/02/"><span class="card-archive-list-date">二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">转载</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AC%E8%BD%BD/" itemprop="url">转载</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>算法</span></a></span></div></div><h1 class="post-title" itemprop="name headline">（转载）cpp算法模板<a class="post-edit-link" href="undefined_posts/（转载）cpp算法模板.md" title="在 GitHub 上编辑 - （转载）cpp算法模板" target="_blank"><i class="anzhiyufont anzhiyu-icon-pencil"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-03-21T02:32:50.000Z" title="发表于 2025-03-21 10:32:50">2025-03-21</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-03-21T03:54:23.194Z" title="更新于 2025-03-21 11:54:23">2025-03-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">15.5k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="（转载）cpp算法模板"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://pic.arctanp.top/PicGo/1742042046711.jpeg?_r_=0fe43d33-1d26-f270-676a-a3edd0e011f3"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://www.cnblogs.com/lightmon5210/p/18183718"><header><a class="post-meta-categories" href="/categories/%E8%BD%AC%E8%BD%BD/" itemprop="url">转载</a><a href="/tags/%E7%AE%97%E6%B3%95/" tabindex="-1" itemprop="url">算法</a><h1 id="CrawlerTitle" itemprop="name headline">（转载）cpp算法模板</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Lightmon</span><time itemprop="dateCreated datePublished" datetime="2025-03-21T02:32:50.000Z" title="发表于 2025-03-21 10:32:50">2025-03-21</time><time itemprop="dateCreated datePublished" datetime="2025-03-21T03:54:23.194Z" title="更新于 2025-03-21 11:54:23">2025-03-21</time></header><h1 id="C-算法模板"><a href="#C-算法模板" class="headerlink" title="C++算法模板"></a>C++算法模板</h1><h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quickSort</span>(q, l, j), <span class="built_in">quickSort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bSearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bSearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bSearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps) &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><h4 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">//存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">//将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>()); <span class="comment">//去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="尺取法（双指针）"><a href="#尺取法（双指针）" class="headerlink" title="尺取法（双指针）"></a>尺取法（双指针）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常见问题分类：</span></span><br><span class="line">    <span class="comment">//(1) 对于一个序列，用两个指针维护一段区间</span></span><br><span class="line">    <span class="comment">//(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span></span><br></pre></td></tr></table></figure>

<h2 id="数论与数学知识"><a href="#数论与数学知识" class="headerlink" title="数论与数学知识"></a>数论与数学知识</h2><h3 id="c-求上取整"><a href="#c-求上取整" class="headerlink" title="c++求上取整"></a>c++求上取整</h3><p>⌈lp⌉&#x3D;⌊l+p−1p⌋</p>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * a % c; <span class="comment">//不可写成res *= a % c</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * a % c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><h4 id="费马小定理求逆元"><a href="#费马小定理求逆元" class="headerlink" title="费马小定理求逆元"></a>费马小定理求逆元</h4><p>费马小定理(Fermat’s little theorem)是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E8%AE%BA/3700?fromModule=lemma_inlink">数论</a>中的一个重要<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AE%9A%E7%90%86/9488549?fromModule=lemma_inlink">定理</a>，在1636年提出。如果p是一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fromModule=lemma_inlink">质数</a>，而<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B4%E6%95%B0/1293937?fromModule=lemma_inlink">整数</a>a不是p的倍数，则有</p>
<p>ap−1≡1(mod p)</p>
<p>对上式变形得</p>
<p>ap−2a≡1(mod p)</p>
<p>则a mod p的逆元是ap−2</p>
<p>接下来通过<code>qpow(a, p - 2, p)</code>即可求出a mod p的逆元</p>
<h4 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h4><p>基于费马小定理，求a mod p的逆元。</p>
<p>要求是p是一个质数，并且p与a互质。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (LL)ans * a % k;</span><br><span class="line">        a = (LL)a * a % k;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">q_pow</span>(a, p - <span class="number">2</span>, p);</span><br><span class="line">    <span class="keyword">if</span> (a % p) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线性逆元"><a href="#线性逆元" class="headerlink" title="线性逆元"></a>线性逆元</h4><p>证明：</p>
<p>线性求解n个数字的逆元，需要找到新元素的逆元同以往求解过逆元的关系。<br>以下面式子举例,对于要求解逆元的k,模数为p，有：<br>p&#x3D;ak+b (b&lt;a,k)</p>
<p>进而有：<br>ak+b≡0(modp)</p>
<p>两边同时乘以k-1b-1,得到：</p>
<p>ab−1+k−1≡0(modp)</p>
<p>即<br>k−1≡−ab−1(modp)</p>
<p>我们知道，<br>a&#x3D;⌊pk⌋</p>
<p>b&#x3D;pmodk</p>
<p>因此，有</p>
<p>k−1≡−⌊pk⌋(pmodk)−1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    inv[i] = (p - p / i) * inv[p % i] % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求解n个不同数字的逆元</p>
<p>求解n个不同数字的逆元，可以先维护一个前缀积，其最后一项是所有数字的乘积，求该项的逆元即求所有项逆元的乘积。由于逆元的特殊性质，逆元的乘积乘上其中某个元素即会消去对应的元素，因此我们可以借助前缀积来逐个迭代处理出所有数字的逆元。</p>
<p>(∏i&#x3D;1nai)−1≡∏i&#x3D;1nai−1(mod p)</p>
<p>或</p>
<p>(a1a2…an)−1≡a1−1a2−1…an−1(mod p)</p>
<p>且有</p>
<p>∏i&#x3D;1nai−1∗an≡∏i&#x3D;1n−1ai−1</p>
<p>于是便可以处理处所有元素的逆元：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">	s[i] = s[i - <span class="number">1</span>] * a[i] % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inv[n] = <span class="built_in">qpow</span>(s[n],p - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line">	inv[i] = inv[i + <span class="number">1</span>] * a[i + <span class="number">1</span>] % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">	inv[i] = inv[i] * s[i - <span class="number">1</span>] % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span>  <span class="comment">// 扩展欧几里得算法, 求x, y，使得ax + by = gcd(a, b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//d始终都是a和b的最大公约数, 倒着传参是为了简化计算</span></span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">    <span class="comment">//返回d，使得能够在求最大公约数的同时完成x，y的凑整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (r = <span class="number">1</span>, c = <span class="number">1</span>; c &lt;= n; c ++) &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) - <span class="built_in">fabs</span>(a[t][c]) &gt; eps) t = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != r) <span class="built_in">swap</span>(a[t], a[r]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &gt;= c; i --) a[r][i] /= a[r][c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n + <span class="number">1</span>; j &gt;= c; j --)</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        &#125;</span><br><span class="line">        r ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n + <span class="number">1</span>]) &gt; eps) <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 代表有无穷多组解</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 代表无解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">            a[i][n + <span class="number">1</span>] -= a[i][j] * a[j][n + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 代表有唯一组解</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h3><h4 id="朴素筛法"><a href="#朴素筛法" class="headerlink" title="朴素筛法"></a>朴素筛法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">            primes[cnt ++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; i &lt;= n; j += i) st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度分析：</p>
<p>每个数的倍数都被筛掉了，因此时间复杂度为：</p>
<p>n2+n3+⋯+nn</p>
<p>&#x3D;n(12+13+…+1n)</p>
<p>&#x3D;n(ln(n)+c) 其中c是一个欧拉常数，是一个无限不循环小数，值是0.577左右</p>
<h4 id="质数定理"><a href="#质数定理" class="headerlink" title="质数定理"></a>质数定理</h4><p>1~n中有nln(n)个质数</p>
<p>我们可以只用把质数的倍数删掉，这样粗劣的时间复杂度就是n(ln(n))ln(n)，但是这只是个粗略的估计，这个估计是不对的，真实的时间复杂度是O(nlog(log(n)))。</p>
<p>这个算法也就是下面的埃氏筛法。</p>
<h4 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(nloglogn)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getPrimes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            prime[idx++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + i; j &lt;= n; j += i) st[j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h4><p>线性筛法在107次方的情况下会比埃氏筛法快一倍左右，在106的情况下两个算法速度差不多。</p>
<p>整体思路：n只会被它的最小质因子筛掉</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrimes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt++] = i; </span><br><span class="line">        <span class="comment">// primes[j] &lt;= n / i即primes * i &lt;= n，即x &lt;= n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++) &#123;</span><br><span class="line">            <span class="comment">// 当还没有执行到下面的break语句时</span></span><br><span class="line">            <span class="comment">// 由于我们是从小到大枚举所有质数的，且还没有枚举到i的最小质因子</span></span><br><span class="line">            <span class="comment">// 所以当前的primes[j]一定是primes[j] * i的最小质因子</span></span><br><span class="line">            <span class="comment">// 所以就把primes[j] * i筛掉</span></span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 当这段代码执行的时候就意味着primes[j]一定是i的最小质因子</span></span><br><span class="line">            <span class="comment">// primes[j]是从小到大枚举的质数，当第一次满足i % primes[j] == 0的时候</span></span><br><span class="line">            <span class="comment">// 说明primes[j]就一定是i的最小质因子</span></span><br><span class="line">            <span class="comment">// 同时此时primes[j]也一定是primes[j] * i的最小质因子</span></span><br><span class="line">            <span class="comment">// 因此上面的筛成立</span></span><br><span class="line">            <span class="comment">// 当如果此时再继续向后枚举质数，接下来的质数就不是primes[j] * i的最小质因子了</span></span><br><span class="line">            <span class="comment">// 因此要即时break掉</span></span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>证明线性：</p>
<p>对于一个合数x，假设primes[j]是x的最小质因子，当i枚举到x&#x2F;primes[j]的时候，我们就可以在4到18行把x给筛掉。</p>
<p>第五行的判断条件不需要加j &lt;&#x3D; cnt</p>
<p>因为当i是合数的时候，primes[j]一定会在枚举到i的最小质因子时停下来，而i的最小质因子一定是小于i的，会在i之前被标记为primes，放到primes数组中来。</p>
<p>当i是质数的时候，当primes[j]&#x3D;i的时候，枚举也会停下来。（是在break的时候停下来）</p>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>ϕ(n): 1~n中和n互质的数的个数</p>
<p>ϕ(6)&#x3D;2</p>
<p>一个数可以写成很多个质数的乘积的形式：</p>
<p>N&#x3D;P1α1P2α2…Pkαk</p>
<p>ϕ(N)&#x3D;N(1−1p1)(1−1p2)…(1−1pk)</p>
<p>上式的证明会用到容斥原理。</p>
<p>那么如何计算从1~N中和N互质的数的个数呢</p>
<ul>
<li><p>从1~N中去掉p1，p2，…，pk的所有倍数</p>
<p>这里面就会多去一部分数，比如一个数可能既是p1的倍数又是p2的倍数</p>
</li>
<li><p>加上所有pi*pj的倍数</p>
<p>N−NP1−NP1−…−NP1+NP1P2+NP1P3+…</p>
</li>
<li><p>减去所有三个质数的倍数</p>
<p>…</p>
</li>
</ul>
<p>然后把最上面的式子展开，会发现这两个式子是相等的。</p>
<p>时间复杂度：时间复杂度瓶颈在分解质因数上，分解质因数的时间复杂度是O(N)</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h4><p>φ(ab)&#x3D;φ(a)φ(b)gcd(a,b)φ(gcd(a,b))</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getEuler</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            prime[cnt ++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; j ++)&#123;</span><br><span class="line">            st[prime[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 此时pj是i的最小质因子，i的质因子中有j了，所以pj*i的所有(1-pj*i的质因子)都在phi[i]中计算过了，因此两者的区别就只有式子开头的N，所以phi[pj * i] = phi[i] * prime[j]</span></span><br><span class="line">                phi[prime[j] * i] = phi[i] * prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里pj - 1就是(1 - 1 / pj) * pj</span></span><br><span class="line">            phi[prime[j] * i] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        res += phi[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h3><h4 id="组合数1"><a href="#组合数1" class="headerlink" title="组合数1"></a>组合数1</h4><p>主要思想：Cab&#x3D;Ca−1b−1×Ca−1b</p>
<p>时间复杂度：O(n^2)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>) c[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组合数2"><a href="#组合数2" class="headerlink" title="组合数2"></a>组合数2</h4><p>预处理阶乘</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fact[N], infact[N];<span class="comment">//存的分别是i的阶乘及其逆元</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求a^k mod p </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line">        fact[i] = (LL) fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        infact[i] = (LL) infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="comment">//这里要及时取模，否则会爆long long</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (LL) fact[a] * infact[b] % mod * infact[a - b] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h3><p>必胜态：从这个状态总是有某种方式走到一个必败态</p>
<p>必败态：从这个状态无论怎么走都是会走到必胜态</p>
<p>如果先手初始处于必败态，那么先手必败，反之先手必胜</p>
<h4 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h4><p>首先，我们定义一个mex函数（或者称为mex操作）：</p>
<p>mex(A): 返回A集合中未曾出现过的最小的自然数</p>
<p>sg(x): 如果处于最终态，则返回0；否则返回该节点可以到达的状态（A集合）中未曾出现过的最小的自然数</p>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h4 id="Dijkstra求最短路-朴素版"><a href="#Dijkstra求最短路-朴素版" class="headerlink" title="Dijkstra求最短路(朴素版)"></a>Dijkstra求最短路(朴素版)</h4><p>Dijkstra算法总体流程：</p>
<ol>
<li>dist[1] &#x3D; 0, dist[i] &#x3D; +∞</li>
<li>for i : 1 ~ n<ul>
<li>t←不在s中的距离最近的点（其中s表示当前已确定最短距离的点的集合）O(n2)</li>
<li>s← t n×O(1)</li>
<li>用t更新其他点的距离 O(m)</li>
</ul>
</li>
</ol>
<p>朴素版dijkstra算法时间复杂度是O（n2）（其中n代表图中点的个数）</p>
<p>因此适合用于稠密图，即边多点少的图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">//存储图，g[i][j]的值是i到j的距离，因为是稠密图，所以用邻接矩阵来存</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">//dist[i]存的是i节点到1节点的最短距离</span></span><br><span class="line"><span class="type">int</span> st[N];   <span class="comment">//st[i]为true说明i节点的值是最小距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环n-1次，即更新n-1次st[?]，这样就把1到1~n这n个节点的最短路都算出来了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//找到未存入最短值且到1节点距离最短的节点t</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if(t == n) goto end;这个优化只有这题能加，意思是当求得1到n的最短路时，即可break，因为这就是题目所求</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//用t节点来更新其他节点（不是t的邻点的话他的g[t][j]就为无穷）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)&#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//end:</span></span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆优化的Dijkstra算法"><a href="#堆优化的Dijkstra算法" class="headerlink" title="堆优化的Dijkstra算法"></a>堆优化的Dijkstra算法</h4><p>堆优化版Dijkstra算法总体流程：</p>
<ol>
<li>dist[1] &#x3D; 0, dist[i] &#x3D; +∞</li>
<li>for i : 1 ~ n<ul>
<li>t←不在s中的距离最近的点（其中s表示当前已确定最短距离的点的集合）O(n)</li>
<li>s← t O(n)</li>
<li>用t更新其他点的距离 O(mlog(n))</li>
</ul>
</li>
</ol>
<p>堆优化版dijkstra算法时间复杂度是O（mlog(n)）（其中n代表图中点的个数, m代表边的个数）</p>
<p>因此适合用于稀疏图，即边少点多的图因此适合用于稀疏图，即边少点多的图因此适合用于稀疏图，即边少点多的图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    e[idx] = y;</span><br><span class="line">    ne[idx] = h[x];</span><br><span class="line">    h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        PII k = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = k.second, distance = k.first;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; distance + w[i])&#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><p>spfa算法</p>
<p>底子是： for 所有边a，b，w</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist[b] = min(dist[b], dist[a] + w)</span><br></pre></td></tr></table></figure>

<p>流程是：<br>queue ← 1<br>while queue不空：</p>
<ol>
<li>t←queue.front(), q.pop();</li>
<li>更新t的所有出边t⟶wb, q←b;</li>
</ol>
<p>spfa求最短路不能处理有自环负权和负权环的情况，这两种情况会在while循环中卡住，所以这题数据不太强</p>
<p>1.stl queue</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st数组是判断当前节点是否在队列当中，防止重复入队</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], q[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// hh指向队头元素，tt指向队尾元素的后一个元素。</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    q[<span class="number">0</span>] = S, st[S] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh != tt)&#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q[tt++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    cout &lt;&lt; dist[T] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;W) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);    <span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);    <span class="comment">// 将边按照权重从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="comment">// 判断两个节点是否在同一个连通块中</span></span><br><span class="line">        <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">            p[a] = b;    <span class="comment">// 将两个连通块合并</span></span><br><span class="line">            res += w;    <span class="comment">// 将边权重累加到结果中</span></span><br><span class="line">            cnt ++ ;     <span class="comment">// 记录加入生成树的边的数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;    <span class="comment">// 判断生成树中是否包含n-1条边</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="keyword">if</span> (t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);    <span class="comment">// 无法生成最小生成树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);             <span class="comment">// 输出最小生成树的权重</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kruskal算法是一种贪心算法，其正确性可以通过贪心选择性质的证明得到。</p>
<p>假设我们要构造一个无向连通图的最小生成树。我们定义一个边集E为“好的”，如果它是某棵最小生成树的子集。我们定义一个边集E为“坏的”，如果它包含了某个环上的边。</p>
<p>首先我们考虑一个引理：对于任何的连通图，E为“好的”，则E中的边是没有环的。</p>
<p>证明：如果E中存在环，则我们可以从中删去任意一条边，得到一个更小的E集合，仍然满足“好的”性质。因此，在“好的”边集中，所有的边都没有构成环。</p>
<p>然后我们考虑另一个引理：对于任何的连通图，令E为“好的”边集合，令e为一条“好的”边，并令E′&#x3D;E∖e。则E′为某棵生成树的子集。</p>
<p>证明：因为e为“好的”边，所以E中不包含e的时候，E仍然是连通的。因此，E′也是连通的。由于E′中没有环，所以它也是无向无环图，也就是一棵树。此外，E′中有n−1条边，与任何生成树的边数相同，所以E′也是某棵生成树的子集。</p>
<p>有了上面的两个引理，我们可以得到Kruskal算法的正确性证明：</p>
<ol>
<li>初始化E为空集；</li>
<li>将所有边按照权值从小到大排序；</li>
<li>依次考虑每条边e，如果将其加入E不会产生环，则将其加入E中；</li>
<li>当加入了n−1条边后，停止算法。此时E即为一棵生成树。</li>
</ol>
<p>根据引理1，E中所有的边没有环；根据引理2，算法停止时，E为某棵生成树的子集；根据Kruskal算法的贪心选择性质，我们知道E为全局最优的“好的”边集合，因此E中的边必定构成了一棵最小生成树。</p>
<p>因此，Kruskal算法的正确性得证。</p>
<h3 id="LCA-最近公共祖先"><a href="#LCA-最近公共祖先" class="headerlink" title="LCA(最近公共祖先)"></a>LCA(最近公共祖先)</h3><p>倍增法求LCA的步骤为：</p>
<ul>
<li>把两个点跳到同一层, 即把下面的x跳到和y同一层</li>
<li>在depth[x] &#x3D;&#x3D; depth[y]之后，<ol>
<li>x &#x3D;&#x3D; y 则该点就是x和y的最近公共祖先</li>
<li>x !&#x3D; y 即他俩同层但不相同，则继续让两个点同时往上跳，一直跳到他们的最近公共祖先的下面一层</li>
</ol>
</li>
</ul>
<p>这里跳到最近公共祖先的下一层是因为不这样做的话有可能我们某一次跳过头了，跳过了lca, 来到了lca的某一个祖宗节点上，这样我们就无法判断lca在现处节点下面的哪一层上了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// depth表示某个节点在树中的深度，其中根节点的dpeth为1, 越往下深度越大。</span></span><br><span class="line"><span class="comment">// fa[i][k]指节点i向上走2^k布所能到达的节点。</span></span><br><span class="line"><span class="comment">// fa的第二个参数，是向上走的最大距离取log下取整，这里是对点数4e4取log得15</span></span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过宽搜来初始化depth和fa数组。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    <span class="comment">// 这里depth[0] = 0起哨兵作用，以防跳出根节点之上。</span></span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[root] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>) &#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k ++) &#123;</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k --) &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b]) &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使a尽量跳到和b同层，并最终一定能跳到。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k --) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[b][k]) &#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dfs版本预处理"><a href="#dfs版本预处理" class="headerlink" title="dfs版本预处理"></a>dfs版本预处理</h4><p>同时顺便求出每个节点向上对应步数的最小的边权</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    f[u][<span class="number">0</span>] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; <span class="number">1</span> &lt;&lt; i &lt; depth[u]; i ++) &#123;</span><br><span class="line">        f[u][i] = f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        minv[u][i] = <span class="built_in">min</span>(minv[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>], minv[u][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        minv[j][<span class="number">0</span>] = w[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="欧拉路径与欧拉回路"><a href="#欧拉路径与欧拉回路" class="headerlink" title="欧拉路径与欧拉回路"></a>欧拉路径与欧拉回路</h3><p>欧拉路径：如果在一张图中，可以从一点出发遍历所有的边，每条边只能遍历一次，那么遍历过程中的这条路径就叫做欧拉路径。</p>
<p>欧拉回路：通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。</p>
<h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><p>dfs变形：在普通的dfs中，我们通常选择对点进行判重，但在求欧拉路径的时候，因为存在环，所以一个点可能被遍历多次，因此我们采取对边判重。</p>
<p>dfs删边优化：因为欧拉路径中每条边只走一次，因此我们可以在每条边被遍历之后把它删除，以节省判重时间，达到时间上的优化。</p>
<p>注意遍历时要写成<code>i = h[u]</code>，可以考虑节点1有3个自环(有向边)。<br>写<code>i = h[u]</code>的话在遍历完三条边回溯的时候，接下来要遍历的边都是<code>h[u] = -1</code>，即遍历结束，保证了每条边都被遍历一次，且时间是线性的。<br>如果写<code>i = ne[i]</code>的话，则在回溯到第二条边的遍历for循环时，接下来还是会枚举到<code>ne[i]</code>，即第三条边（之后会在第三条边的for循环中continue出来）。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/static/img/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://www.cnblogs.com/static/img/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF.png" alt="img"></a></p>
<p>上图即为dfs的遍历顺序，可以发现蓝色的边倒序即是欧拉路径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, type, cnt, ans[M];</span><br><span class="line"><span class="type">int</span> used[<span class="number">2</span> * M];</span><br><span class="line"><span class="type">int</span> in[N], out[N];</span><br><span class="line"><span class="type">int</span> h[N], e[<span class="number">2</span> * M], ne[<span class="number">2</span> * M], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意这里要写成i = h[u]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = h[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            h[u] = ne[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        used[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) used[i ^ <span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 若为无向图，则将反向边判重</span></span><br><span class="line">        h[u] = ne[i];</span><br><span class="line">        <span class="built_in">dfs</span>(e[i]);</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span>) ans[++cnt] = -(i + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> ans[++cnt] = (i + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ans[++cnt] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fleury"><a href="#fleury" class="headerlink" title="fleury"></a>fleury</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/static/img/fleury.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://www.cnblogs.com/static/img/fleury.png" alt="img"></a></p>
<p>感觉和dfs算法基本一致，该算法在有桥的时候时间复杂度为O(m2)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;PII&gt; G[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (G[u].<span class="built_in">size</span>()) &#123;</span><br><span class="line">		pii p = G[u].<span class="built_in">back</span>();</span><br><span class="line">		G[u].<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">if</span> (vis[p.scd]) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[p.scd] = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(p.fst);</span><br><span class="line">	&#125;</span><br><span class="line">	stk[++top] = pr[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="单链表（静态）"><a href="#单链表（静态）" class="headerlink" title="单链表（静态）"></a>单链表（静态）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//head是头指针，e存权值，ne存下一个节点，idx分配节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>; <span class="comment">//链表中最后一个节点的ne始终是-1</span></span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">//在头结点前建立节点</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head; </span><br><span class="line">    head = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_k</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> r[N], l[N], e[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1节点和0节点相当于变相的head指针，没有e值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在k节点的右边插入值为x的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx; <span class="comment">//必须先做这个，否则后面的r[k]会被修改掉</span></span><br><span class="line">    r[k] = idx;</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="一般队列"><a href="#一般队列" class="headerlink" title="一般队列"></a>一般队列</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    q[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hh++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[hh];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>主要在bfs及spfa算法中使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q[N];</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[tt++] = x;</span><br><span class="line">    st[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (hh != tt) &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> () &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>以滑动窗口为例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, k; <span class="comment">// k代表滑动窗口的长度</span></span><br><span class="line"><span class="type">int</span> a[N], q[N];</span><br><span class="line"><span class="type">int</span> hh, tt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="number">1</span>) hh ++;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt --;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="一般栈"><a href="#一般栈" class="headerlink" title="一般栈"></a>一般栈</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> stack[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    stack[++ tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tt --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tt &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack[tt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; op;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> b = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> a = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> c = op.<span class="built_in">top</span>(); op.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>) x = a + b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) x = a - b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) x = a * b;</span><br><span class="line">    <span class="keyword">else</span> x = a / b;</span><br><span class="line">    num.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pr&#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> c = str[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>, j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j]))</span><br><span class="line">                x = x * <span class="number">10</span> + str[j ++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">            num.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) op.<span class="built_in">push</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (op.<span class="built_in">size</span>() &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[c]) <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (op.<span class="built_in">size</span>()) <span class="built_in">eval</span>();</span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= a[i]) tt --;</span><br><span class="line">        <span class="keyword">if</span> (tt) cout &lt;&lt; stk[tt] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        stk[++ tt] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000010</span>], p[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> ne[<span class="number">100010</span>];</span><br><span class="line"><span class="comment">// ne[1] = 0, ne[2]的值不确定，注意next数组的定义可能会有多种</span></span><br><span class="line"><span class="comment">// 有些定义下的ne[2]的值必定是1</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//构造next数组，存储最大公共前后缀</span></span><br><span class="line">    <span class="comment">//i从2开始，默认ne[1] = 0.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="comment">//求ne[i]的时候ne[i - 1]已经求出来了, 此时j和i-1对齐</span></span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j]; <span class="comment">//j回滚到当前前缀串的最大公共前缀串</span></span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++; <span class="comment">//p[i]与p[j + 1]匹配成功，可以匹配下一个位置, 这里让匹配好的j(p串匹配好的字符数)变成j + 1</span></span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匹配sp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - j);</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TRIE"><a href="#TRIE" class="headerlink" title="TRIE"></a>TRIE</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>; <span class="comment">//存的是所有节点的最大个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;  <span class="comment">// 每次从根节点开始找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++; <span class="comment">//标记不是打在要插入的字符串的最后一个字母对应的节点的下一个节点上的***</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], pk[N], kp[N];</span><br><span class="line"><span class="type">int</span> idx, len; <span class="comment">//idx是用来维护第几个插入堆中的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hswap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">    <span class="built_in">swap</span>(pk[a], pk[b]);</span><br><span class="line">    <span class="built_in">swap</span>(kp[pk[a]], kp[pk[b]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">hswap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u /= <span class="number">2</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= len &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= len &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)&#123;</span><br><span class="line">        <span class="built_in">hswap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    h[++len] = x;</span><br><span class="line">    pk[len] = ++idx;</span><br><span class="line">    kp[idx] = len;</span><br><span class="line">    <span class="built_in">up</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delmin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">hswap</span>(<span class="number">1</span>, len);</span><br><span class="line">    len --;</span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">hswap</span>(u, len);</span><br><span class="line">    len --;</span><br><span class="line">    <span class="built_in">down</span>(u);</span><br><span class="line">    <span class="built_in">up</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void del(int k)&#123;</span></span><br><span class="line"><span class="comment">//     int t = kp[k];</span></span><br><span class="line"><span class="comment">//     hswap(kp[k], len);</span></span><br><span class="line"><span class="comment">//     len --;</span></span><br><span class="line"><span class="comment">//     up(t);</span></span><br><span class="line"><span class="comment">//     down(t);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    h[u] = x;</span><br><span class="line">    <span class="built_in">up</span>(u), <span class="built_in">down</span>(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p[i]存储i节点的祖宗节点，d[i]存储i节点到祖宗节点的距离</span></span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找祖宗节点，同时更新d数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != p[x]) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="comment">//x到祖宗的距离=x到p[x]的距离+p[x]到祖宗的距离</span></span><br><span class="line">        <span class="comment">//这里的距离更新仅仅是更新的d[x]正确（找祖先）的情况下，在做并差集合并时还得手动更新</span></span><br><span class="line">        d[x] = d[x] + d[p[x]];</span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != p[x]) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(a[k] != null &amp;&amp; a[k] != x)&#123;</span><br><span class="line">        k ++;</span><br><span class="line">        <span class="keyword">if</span>(k == N) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树状数组和线段树"><a href="#树状数组和线段树" class="headerlink" title="树状数组和线段树"></a>树状数组和线段树</h3><h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><p>“树状数组的下标从1开始,不可以从0开始,因为lowbit(0)&#x3D;0时会出现死循环”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//lowbit这个函数的功能就是求某一个数的二进制表示中最低的一位1，举个例子，</span></span><br><span class="line">    <span class="comment">//x = 6，它的二进制为110，那么lowbit(x)就返回2，因为最后一位1表示2</span></span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">//求1~x的和</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == tr[u].r) tr[u].sum += v;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树链剖分（重链剖分）"><a href="#树链剖分（重链剖分）" class="headerlink" title="树链剖分（重链剖分）"></a>树链剖分（重链剖分）</h3><p>将树中任意一条路径转化为O(logn)段连续区间</p>
<ol>
<li>将一棵树转化为一个序列</li>
<li>树中路径转化为logn段连续区间</li>
</ol>
<p>dfs序（dfn）：优先遍历重儿子，即可保证重链上所有点的编号是连续的，注意这里的dfs是按照优先遍历重儿子来的dfs序</p>
<p>定理：树中任意一条路径均可拆分成O(logn)条重链，即可拆分成O(logn)段连续区间</p>
<p>重儿子：某个节点的所有子树中size最大的那个的父节点是当前节点的重儿子，其他节点为轻儿子</p>
<p>重边：重儿子往他的父节点去的边</p>
<p>轻边：其他所有边</p>
<p>重链：重边构成的极大的一条链</p>
<p>重儿子所在的重链的top是他往上的轻儿子，轻儿子所在的重链的top是他自己</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/lightmon233/Algorithm-Note/main/static/img/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://raw.githubusercontent.com/lightmon233/Algorithm-Note/main/static/img/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86.png" alt="img"></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> w[N], h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> id[N], nw[N], cnt;</span><br><span class="line"><span class="type">int</span> dep[N], sz[N], top[N], fa[N], son[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理出来每个点的重儿子，深度，所在子数大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    dep[u] = depth, fa[u] = father, sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(j, u, depth + <span class="number">1</span>);</span><br><span class="line">        sz[u] += sz[j];</span><br><span class="line">        <span class="keyword">if</span> (sz[son[u]] &lt; sz[j]) son[u] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算出每个节点的dfn序，每个节点所在的重链的顶点是谁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    id[u] = ++cnt, nw[cnt] = w[u], top[u] = t;</span><br><span class="line">    <span class="keyword">if</span> (!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa[u] || j == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树上启发式合并"><a href="#树上启发式合并" class="headerlink" title="树上启发式合并"></a>树上启发式合并</h3><p>用同一套数组（当然也可以是其他数据结构）来记录所有子树的信息，在更新新的子树信息前把当前子树的信息存下来。</p>
<p>一般地思考的话，我们可以在每次算完当前子树信息，将要回溯的时候，把数组全部清空，但是这样时间复杂度会达到n^2级别，因此考虑优化。</p>
<p>结论：每次先算轻儿子为根的子树，再算重儿子为根的子树，利用重儿子为根的子树的信息来更新当前节点为根的子树的信息。并且在算完轻儿子为根的子树的信息后清空信息。这样可以把时间复杂度压缩为O(logn)</p>
<p>为什么呢？</p>
<p>考虑每个节点对答案的贡献次数，即搜索次数, 即这个点所在的所有子树中，有多少棵会被遍历。由遍历策略导致，只有轻儿子为根的子树才会被重复遍历。因此贡献次数取决于当前节点所在的子树中有多少棵子树是他父节点的轻儿子。换句话来说，就是当前节点到根节点的路径中，有多少条边是轻边。由树链剖分的性质可知最多有logn条轻边。</p>
<p>为什么是logn条轻边呢？</p>
<p>因为我们从当前点往上走，每走一条轻边，子树的元素个数至少乘2，因为上面的父节点会有重儿子且不是当前节点。所以最多只能走logn条轻边。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs0</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs0</span>(j, u);</span><br><span class="line">        sz[u] += sz[j];</span><br><span class="line">        <span class="keyword">if</span> (sz[j] &gt; sz[son[u]]) son[u] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pson代表当前u的重儿子，即不要重复算重儿子的部分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> sign, <span class="type">int</span> pson)</span> </span>&#123;</span><br><span class="line">    cnt[c[u]] += sign;</span><br><span class="line">    <span class="keyword">if</span> (cnt[c[u]] &gt; mx) mx = cnt[c[u]], sum = c[u];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt[c[u]] == mx) sum += c[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa || j == pson) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">update</span>(j, u, sign, pson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// op代表u是重儿子还是轻儿子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa || j == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(j, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) <span class="built_in">dfs</span>(son[u], u, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">update</span>(u, fa, <span class="number">1</span>, son[u]);</span><br><span class="line">    ans[u] = sum;</span><br><span class="line">    <span class="keyword">if</span> (!op) <span class="built_in">update</span>(u, fa, <span class="number">-1</span>, <span class="number">0</span>), sum = mx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h3><h4 id="基础莫队"><a href="#基础莫队" class="headerlink" title="基础莫队"></a>基础莫队</h4><p>本质是通过排序优化了普通尺取法的时间复杂度。</p>
<p>考虑如果某一列询问的右端点是递增的，那么我们更新答案的时候，右指针只会从左往右移动，那么i指针的移动次数是O(n)的。</p>
<p>当然，我们不可能让左右端点都单调来做到总体O(n)。</p>
<p>考虑对左端点进行分块。</p>
<p>莫队排序：<br>左端点按照分块的编号来排，如果分块编号不同的话编号较小的靠前，如果相同的话右端点小的在前。可以证明这样排完序的话时间复杂度可以做到O(nn)。</p>
<p>这样我们把区间分成了n块，每块的长度都是n，在每一块内部，所有查询的右端点是递增的。</p>
<p>右指针：在每一块内部，右端点递增，所以右端点走的总数不会超过n（注意每一块内部放的是左端点，右端点是完全有可能超出这个块的范围的，因此这里为n），一共有n块，所以右端点总共走的次数不会超过nn。</p>
<p>左指针：先考虑每一次询问：</p>
<ol>
<li>左指针在块内部移动，块的长度是n，因此最多只会移动n次。</li>
<li>左指针在相邻两块之间移动，最坏是从第一个块的左端点移动到第二个块的右端点，因此最坏移动2n次。</li>
</ol>
<p>因为有q次询问，所以1是qn，2是2n。<br>因为一共有n个块，我们从前往后要跨过n−1次，每次最多是2n，所以时间复杂度是2n。</p>
<p>所以总时间复杂度为O(qn)。</p>
<h5 id="玄学优化"><a href="#玄学优化" class="headerlink" title="玄学优化"></a>玄学优化</h5><p>奇数块：块内按照右端点从小到大排。</p>
<p>偶数快：块内按照右端点从大到小排。</p>
<p>二者可以互换。</p>
<p>前一段从左到右滚，右端点从左滚到了右边接近n的位置，下一次从右到左滚，可以更方便一些，相当于更加顺路了。</p>
<p>如果我们块的大小是a的话，那么块的数量就是na，那么r的复杂度就是nan&#x3D;n2a，l的复杂度是qa（只考虑块内），总复杂度为两者之和，当两者相等时取得最小值，解得a&#x3D;n2q。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码为统计一段区间上是否有不相同的数，没有输出yes</span></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; v;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">210</span>];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adds</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[x]) res ++;</span><br><span class="line">    cnt[x] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> &amp;res)</span> </span>&#123;</span><br><span class="line">    cnt[x] --;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[x]) res --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    len = <span class="built_in">max</span>(<span class="number">1</span>, (<span class="type">int</span>)<span class="built_in">sqrt</span>((<span class="type">double</span>)n * n / q));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] += <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        v.<span class="built_in">push_back</span>(&#123;i, l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [&amp;](array&lt;<span class="type">int</span>, <span class="number">3</span>&gt; &amp;a, array&lt;<span class="type">int</span>, <span class="number">3</span>&gt; &amp;b) &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">get</span>(a[<span class="number">1</span>]), j = <span class="built_in">get</span>(b[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i != j) <span class="keyword">return</span> i &lt; j;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="comment">// i是右指针，j是左指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">1</span>, res = <span class="number">0</span>; k &lt; q; k ++) &#123;</span><br><span class="line">        <span class="type">int</span> id = v[k][<span class="number">0</span>], l = v[k][<span class="number">1</span>], r = v[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; r) <span class="built_in">adds</span>(a[++ i], res);</span><br><span class="line">        <span class="keyword">while</span> (i &gt; r) <span class="built_in">del</span>(a[i --], res);</span><br><span class="line">        <span class="keyword">while</span> (j &lt; l) <span class="built_in">del</span>(a[j ++], res);</span><br><span class="line">        <span class="keyword">while</span> (j &gt; l) <span class="built_in">adds</span>(a[-- j], res);</span><br><span class="line">        ans[id] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i ++)</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对顶堆"><a href="#对顶堆" class="headerlink" title="对顶堆"></a>对顶堆</h3><h4 id="双set版本"><a href="#双set版本" class="headerlink" title="双set版本"></a>双set版本</h4><p>双set用来实现元素的删除操作比优先队列要考虑的细节要少，所以一般用双set来实现对顶堆。</p>
<p>因为奇偶对应的中位数位置不一样，所以一般要进行奇偶讨论。</p>
<p>s1为大根堆，s2为小跟堆，我们实现的时候保证两个堆里面的元素个数相同，堆的大小始终为偶数，其中mid来维护中位数。</p>
<p>当当前维护了奇数个元素时，对顶堆由s1，s2，mid共同组成，其中mid代表游离在set之外的中位数。</p>
<p>当当前维护了偶数个元素时，对顶堆由s1，s2共同维护，mid指向两个堆的堆顶之一。</p>
<p>flag用来标记当前元素个数是奇数还是偶数个。如果是奇数个的话flag为1。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/lightmon233/Algorithm-Note/main/static/img/%E5%AF%B9%E9%A1%B6%E5%A0%86.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://raw.githubusercontent.com/lightmon233/Algorithm-Note/main/static/img/%E5%AF%B9%E9%A1%B6%E5%A0%86.png" alt="img"></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line"><span class="type">int</span> sum_l, sum_r, mid;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    s<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">    s<span class="number">2.</span><span class="built_in">clear</span>();</span><br><span class="line">    s<span class="number">1.</span><span class="built_in">insert</span>(-LLF);</span><br><span class="line">    s<span class="number">2.</span><span class="built_in">insert</span>(LLF);</span><br><span class="line">    sum_l = sum_r = mid = <span class="number">0</span>;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="type">int</span> a = *(--s<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> b = *s<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= x &amp;&amp; x &lt;= b) &#123;</span><br><span class="line">            mid = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; x) &#123;</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">erase</span>(s<span class="number">1.f</span>ind(a));</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">insert</span>(x);</span><br><span class="line">            sum_l += x - a;</span><br><span class="line">            mid = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b &lt; x) &#123;</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">erase</span>(s<span class="number">2.f</span>ind(b));</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">insert</span>(x);</span><br><span class="line">            sum_r += x - b;</span><br><span class="line">            mid = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= mid) &#123;</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">insert</span>(mid);</span><br><span class="line">            sum_l += mid;</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">insert</span>(x);</span><br><span class="line">            sum_r += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">insert</span>(mid);</span><br><span class="line">            sum_r += mid;</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">insert</span>(x);</span><br><span class="line">            sum_l += x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flag ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = *(--s<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> b = *s<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= x) &#123;</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">erase</span>(s<span class="number">1.f</span>ind(x));</span><br><span class="line">            sum_l -= x;</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">erase</span>(s<span class="number">2.f</span>ind(b));</span><br><span class="line">            sum_r -= b;</span><br><span class="line">            mid = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">erase</span>(s<span class="number">2.f</span>ind(x));</span><br><span class="line">            sum_r -= x;</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">erase</span>(s<span class="number">1.f</span>ind(a));</span><br><span class="line">            sum_l -= a;</span><br><span class="line">            mid = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mid == x) &#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; mid) &#123;</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">erase</span>(s<span class="number">2.f</span>ind(x));</span><br><span class="line">            s<span class="number">2.</span><span class="built_in">insert</span>(mid);</span><br><span class="line">            sum_r += mid - x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">erase</span>(s<span class="number">1.f</span>ind(x));</span><br><span class="line">            s<span class="number">1.</span><span class="built_in">insert</span>(mid);</span><br><span class="line">            sum_l += mid - x;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆带删除操作版"><a href="#堆带删除操作版" class="headerlink" title="堆带删除操作版"></a>堆带删除操作版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> inh[N];</span><br><span class="line">priority_queue&lt;PII&gt; fh;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;&gt;&gt; sh;</span><br><span class="line"><span class="type">int</span> fsize, rsize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    inh[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (sh.<span class="built_in">size</span>() &amp;&amp; !inh[sh.<span class="built_in">top</span>().second]) sh.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span> (fh.<span class="built_in">size</span>() &amp;&amp; !inh[fh.<span class="built_in">top</span>().second]) fh.<span class="built_in">pop</span>();</span><br><span class="line">    sh.<span class="built_in">emplace</span>(a[i], i);</span><br><span class="line">    <span class="keyword">while</span> (fh.<span class="built_in">size</span>() &amp;&amp; sh.<span class="built_in">size</span>() &amp;&amp; fh.<span class="built_in">top</span>().first &gt; sh.<span class="built_in">top</span>().first) &#123;</span><br><span class="line">        res += sh.<span class="built_in">top</span>().first - fh.<span class="built_in">top</span>().first;</span><br><span class="line">        fh.<span class="built_in">push</span>(sh.<span class="built_in">top</span>());</span><br><span class="line">        sh.<span class="built_in">push</span>(fh.<span class="built_in">top</span>());</span><br><span class="line">        fh.<span class="built_in">pop</span>();</span><br><span class="line">        sh.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (sh.<span class="built_in">size</span>() &amp;&amp; !inh[sh.<span class="built_in">top</span>().second]) sh.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (fh.<span class="built_in">size</span>() &amp;&amp; !inh[fh.<span class="built_in">top</span>().second]) fh.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sh.<span class="built_in">size</span>() &amp;&amp; fsize &lt; k) &#123;</span><br><span class="line">        ++fsize;</span><br><span class="line">        res += sh.<span class="built_in">top</span>().first;</span><br><span class="line">        fh.<span class="built_in">push</span>(sh.<span class="built_in">top</span>());</span><br><span class="line">        sh.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (sh.<span class="built_in">size</span>() &amp;&amp; !inh[sh.<span class="built_in">top</span>().second]) sh.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (fh.<span class="built_in">size</span>() &amp;&amp; !inh[fh.<span class="built_in">top</span>().second]) fh.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (sh.<span class="built_in">size</span>() &amp;&amp; !inh[sh.<span class="built_in">top</span>().second]) sh.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span> (fh.<span class="built_in">size</span>() &amp;&amp; !inh[fh.<span class="built_in">top</span>().second]) fh.<span class="built_in">pop</span>();</span><br><span class="line">    inh[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!sh.<span class="built_in">size</span>() || a[i] &lt; sh.<span class="built_in">top</span>().first) --fsize, res -= a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆仅插入版"><a href="#堆仅插入版" class="headerlink" title="堆仅插入版"></a>堆仅插入版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q1; <span class="comment">// 大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vectoor&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; q2; <span class="comment">// 小根堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!q<span class="number">2.</span><span class="built_in">size</span>() || x &gt; q<span class="number">2.</span><span class="built_in">top</span>()) q<span class="number">2.</span><span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">else</span> q<span class="number">1.</span><span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (q<span class="number">1.</span><span class="built_in">size</span>() &gt; q<span class="number">2.</span><span class="built_in">size</span>() + <span class="number">1</span>) &#123;</span><br><span class="line">        q<span class="number">2.</span><span class="built_in">push</span>(q<span class="number">1.</span><span class="built_in">top</span>());</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q<span class="number">2.</span><span class="built_in">size</span>() &gt; q<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">1</span>) &#123;</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">push</span>(q<span class="number">2.</span><span class="built_in">top</span>());</span><br><span class="line">        q<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主席树（可持久化权值线段树）"><a href="#主席树（可持久化权值线段树）" class="headerlink" title="主席树（可持久化权值线段树）"></a>主席树（可持久化权值线段树）</h3><p>主要适用于解决在线区间第k小数问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> lson, rson;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N * <span class="number">17</span> * <span class="number">18</span>];</span><br><span class="line"><span class="type">int</span> root[N];</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q = ++idx;</span><br><span class="line">    tr[q] = tr[p];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[q].cnt ++;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) tr[q].lson = <span class="built_in">insert</span>(tr[p].lson, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> tr[q].rson = <span class="built_in">insert</span>(tr[p].rson, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    tr[q].cnt = tr[tr[q].lson].cnt + tr[tr[q].rson].cnt;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> q, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> cnt = tr[tr[q].lson].cnt - tr[tr[p].lson].cnt;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= cnt) <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].lson, tr[p].lson, l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].rson, tr[p].rson, mid + <span class="number">1</span>, r, k - cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询中位数的时候直接取个数较多的堆的堆顶即可。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><p>1.朴素版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> dp[N]; <span class="comment">//dp中存的是以a[i]结尾的子序列的集合中最长的子序列的长度</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i])&#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) ans = <span class="built_in">max</span>(ans, dp[j]);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.1模拟栈版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; stk;<span class="comment">//模拟堆栈</span></span><br><span class="line">    stk.<span class="built_in">push_back</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; stk.<span class="built_in">back</span>()) <span class="comment">//如果该元素大于栈顶元素,将该元素入栈</span></span><br><span class="line">            stk.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//替换掉第一个大于或者等于这个数字的那个数</span></span><br><span class="line">            *<span class="built_in">lower_bound</span>(stk.<span class="built_in">begin</span>(), stk.<span class="built_in">end</span>(), arr[i]) = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; stk.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.2二分写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">max</span>(len, r + <span class="number">1</span>);</span><br><span class="line">        q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附：最长不下降子序列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">subseq1</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="comment">// 对原数组的每个下标i(从1开始)，求以a[i]结尾的最长不下降子序列长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// q下标从2开始才放如元素,q[i]是有长度为i-1的子序列的最小的末尾值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> ll = l, rr = len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ll &lt; rr) &#123;</span><br><span class="line">            <span class="type">int</span> mid = ll + rr + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &lt;= a[i]) ll = mid;</span><br><span class="line">            <span class="keyword">else</span> rr = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">max</span>(len, rr);</span><br><span class="line">        q[rr + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二分求出以a[i]结尾的最长不下降子序列长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> l2 = <span class="number">2</span>, r2 = len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l2 &lt; r2) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l2 + r2 + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &lt;= a[i]) l2 = mid;</span><br><span class="line">            <span class="keyword">else</span> r2 = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp1[i] = l2 - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h4><p>状态表示：f[i][j]:在前i个物品中选，总体积不超过j的最大价值。</p>
<h5 id="01背包问题的二维代码"><a href="#01背包问题的二维代码" class="headerlink" title="01背包问题的二维代码"></a>01背包问题的二维代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//动态规划问题一般下标从1开始，便于从0的情况递推结果。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="01背包一维优化"><a href="#01背包一维优化" class="headerlink" title="01背包一维优化"></a>01背包一维优化</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j --) &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>特征：一个物品可以选无数次。</p>
<p>状态表示：f[i][j]表示从前i个物品里选择（一个物品可以选多次），总体积不超过j的最大价值。</p>
<h5 id="完全背包问题的三重循环代码"><a href="#完全背包问题的三重循环代码" class="headerlink" title="完全背包问题的三重循环代码"></a>完全背包问题的三重循环代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k ++) &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二重循环二维的优化过程"><a href="#二重循环二维的优化过程" class="headerlink" title="二重循环二维的优化过程"></a>二重循环二维的优化过程</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01</span></span><br><span class="line">f[i][j]        = <span class="built_in">max</span>(f[i][j],            f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line"><span class="comment">// 完全</span></span><br><span class="line">f[i][j]        = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j],        f[i - <span class="number">1</span>][j - v[i]] + w[i], f[i - <span class="number">1</span>][j - <span class="number">2</span> * v[i]] + <span class="number">2</span> * w[i], .....)</span><br><span class="line">f[i][j - v[i]] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - v[i]], f[i - <span class="number">1</span>][j - <span class="number">2</span> * v[i]] + <span class="number">1</span> * w[i], .....)</span><br></pre></td></tr></table></figure>

<p>三式代入二式，得：<br><code>f[i][j] = max(f[i - 1][j],f[i][j - v[i]] + w[i]);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="完全背包一维最终优化"><a href="#完全背包一维最终优化" class="headerlink" title="完全背包一维最终优化"></a>完全背包一维最终优化</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j ++) &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多重背包1"><a href="#多重背包1" class="headerlink" title="多重背包1"></a>多重背包1</h4><p>特征：一个物品有严格的次数限制。<br>状态表示：f[i][j]表示从前i个物品里选择（一个物品有严格的次数限制），总体积不超过j的价值；</p>
<h5 id="多重背包问题的三重循环代码"><a href="#多重背包问题的三重循环代码" class="headerlink" title="多重背包问题的三重循环代码"></a>多重背包问题的三重循环代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s[i]表示第i种物品共有s[i]个</span></span><br><span class="line"><span class="type">int</span> f[N][N], s[N], v[N], w[N];</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++) &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多重背包问题一维优化代码"><a href="#多重背包问题一维优化代码" class="headerlink" title="多重背包问题一维优化代码"></a>多重背包问题一维优化代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j --) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++) &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - k * v[i]]+ k * w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多重背包问题打包版"><a href="#多重背包问题打包版" class="headerlink" title="多重背包问题打包版"></a>多重背包问题打包版</h5><p>利用二进制优化的思想，把同一种类型的物品按照2的不同次幂个为一组进行打包，从而优化时间复杂度。</p>
<p>时间复杂度：O(nmlogs)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[i]存储第i种物品的个数</span></span><br><span class="line"><span class="comment">// a, b数组存的是原体积和原价值</span></span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ss = s[i];</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= s) &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = k * a[i];</span><br><span class="line">            w[cnt] = k * b[i];</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = s * a;</span><br><span class="line">            w[cnt] = s * b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j --) &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多重背包单调队列优化"><a href="#多重背包单调队列优化" class="headerlink" title="多重背包单调队列优化"></a>多重背包单调队列优化</h5><p>时间复杂度：O(nm)</p>
<p>[<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://cdn.acwing.com/media/article/image/2023/04/15/226750_2e51f2afdb-_~948ZKD%3C!--swig%EF%BF%BC76--%3E1S%7B~4(4~%7BLS_Z2.png" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> g[N]; <span class="comment">// g是f的滚动数组</span></span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(g, f, <span class="keyword">sizeof</span> f); <span class="comment">//把上一层的f存在g里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i]; j ++) &#123;</span><br><span class="line">            <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//滑动窗口长度为s，不包括f[k]本身，因此f[k] = max(f[k], max(others))</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt;= m; k += v[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s[i] * v[i]) hh ++;</span><br><span class="line">                <span class="keyword">if</span> (hh &lt;= tt) f[k] = <span class="built_in">max</span>(f[k], g[q[hh]] + (k - q[hh]) / v[i] * w[i]);</span><br><span class="line">                <span class="comment">//由图中表达式知g数组中的值都是不包含w的，这里我们进行比较只需比较绝对值</span></span><br><span class="line">                <span class="comment">//因此只要营造出递减数列的效果即可</span></span><br><span class="line">                <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v[i] * w[i] &lt;= g[k] - (k - j) / v[i] * w[i]) tt --;</span><br><span class="line">                q[++tt] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h4><p>特征：一组物品只能选择其中的一个。</p>
<p>状态表示：f[i][j]表示从前i组物品里选择(一组物品最多只能选择其中的一个)，总体积不超过j的最大价值；<br>状态计算：<code>f[i][j]=max(f[i-1][j],f[i-1][j-w[i][k]]+v[i][k])</code>(解释；表示从前i组物品里选择体积不超过j的物品价值的最大值是从要么不选这个物品，和要么选择这个组中第k个物品的价值之间进行选择)</p>
<h5 id="分组背包问题一维优化代码"><a href="#分组背包问题一维优化代码" class="headerlink" title="分组背包问题一维优化代码"></a>分组背包问题一维优化代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// w[i][j]代表第i组物品中的第j个的价值，v同</span></span><br><span class="line"><span class="type">int</span> w[N][N],v[N][N];</span><br><span class="line"><span class="comment">// s[i]代表第i组物品有多少个</span></span><br><span class="line"><span class="type">int</span> f[N],s[N];</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i][k] &lt;= j) &#123;</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="背包问题中总体积最多-恰好-最少为j-以求最大值为例-3是最小值"><a href="#背包问题中总体积最多-恰好-最少为j-以求最大值为例-3是最小值" class="headerlink" title="背包问题中总体积最多&#x2F;恰好&#x2F;最少为j, 以求最大值为例(3是最小值)"></a>背包问题中总体积最多&#x2F;恰好&#x2F;最少为j, 以求最大值为例(3是最小值)</h4><ol>
<li>体积最多为j：<code>memset(f, 0, sizeof f), v &gt;= 0</code></li>
<li>体积恰好为j：<code>memset(f, -0x3f, sizeof f), ,f[0] = 0, v &gt;= 0</code></li>
</ol>
<ul>
<li>怎么保证是恰好装满，通过初始化来实现, 如果不存在使f[i]满足是恰好装满的，那么这个f[i] &#x3D; -INF, 即一个非法答案，就不会影响最终的计算。</li>
</ul>
<ol>
<li>体积至少为j：<code>memset(f, -0x3f, sizeof f), f[0] = 0</code></li>
</ol>
<ul>
<li>f[i][j]: 从前i件物品中选，总体积至少为j的最小价值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">            f[j] = <span class="built_in">min</span>(f[j], f[<span class="built_in">max</span>(<span class="number">0</span>, j - v[i])] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h4><p>f[u][j]: 表示在以u为根的子树中选，且先选出u（因为其他节点都依赖u, 这样表示状态会简单一点，可以往分组背包(其实也不完全是分组背包，也就物品组和枚举决策的概念上比较像分组背包)上面套），总体积不超过j的最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相当于分组背包问题中的物品组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> son = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(son);</span><br><span class="line">        <span class="comment">// 先求一下所有子树中的最大价值, 故先在最大体积中把当前节点去掉</span></span><br><span class="line">        <span class="comment">// 枚举体积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m - v[u]; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">            <span class="comment">// 枚举决策，这里以选取体积为多少讨论决策</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j; k ++) &#123;</span><br><span class="line">                f[u][j] = <span class="built_in">max</span>(f[u][j], f[u][j - k] + f[son][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后记得把当前节点加上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[u]; j --) f[u][j] = f[u][j - v[u]] + w[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = v[u] - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --) f[u][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(root);</span><br></pre></td></tr></table></figure>

<p>另一种模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f[<span class="number">110</span>][<span class="number">110</span>];<span class="comment">//f[x][v]表达选择以x为子树的物品，在容量不超过v时所获得的最大价值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">110</span>], w[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> n, m, root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = v[x]; i &lt;= m; i ++) f[x][i] = w[x];<span class="comment">//点x必须选，所以初始化f[x][v[x] ~ m]= w[x]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[x].<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">        <span class="type">int</span> y = g[x][i];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[x]; j --)<span class="comment">//j的范围为v[x]~m, 小于v[x]无法选择以x为子树的物品</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j - v[x]; k ++)<span class="comment">//分给子树y的空间不能大于j-v[x],不然都无法选根物品x</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[x][j] = <span class="built_in">max</span>(f[x][j], f[x][j - k] + f[y][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h4><p>由于01背包、完全背包、多重背包的转移方程只和当前的第i个物品的类型有关，与前面的物品无关，所以可以对不同的类型物品独立地使用不同的状态转移方程。</p>
<h2 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h2><h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h3><p>源自冶金术语，将材料加热后再经特定速率冷却的技术，目的是增大晶粒体积，减少晶格中的缺陷，以改变材料的物理性质。</p>
<p>材料中的原子原来会停留在使内能有局部最小值的位置，加热使能量变大，原子会离开原来的位置，随机在其他位置游走，退火冷却时速度较慢，使得原子有较多可能可以移动到内能比原先更低的位置。</p>
<p><a target="_blank" rel="noopener" href="https://upload.wikimedia.org/wikipedia/commons/d/d5/Hill_Climbing_with_Simulated_Annealing.gif"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://upload.wikimedia.org/wikipedia/commons/d/d5/Hill_Climbing_with_Simulated_Annealing.gif" alt="img"></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">simulate_anneal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">PDD <span class="title">cur</span><span class="params">(rdd(<span class="number">0</span>, <span class="number">10000</span>), rdd(<span class="number">0</span>, <span class="number">10000</span>))</span></span>;</span><br><span class="line">    <span class="comment">// t为退火温度，也即随机范围。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> t = <span class="number">1e4</span>; t &gt; <span class="number">1e-4</span>; t *= <span class="number">0.9</span>) &#123;</span><br><span class="line">        <span class="function">PDD <span class="title">np</span><span class="params">(rdd(cur.first - t, cur.first + t), rdd(cur.second - t, cur.second + t))</span></span>;</span><br><span class="line">        <span class="type">double</span> dt = <span class="built_in">calc</span>(np) - <span class="built_in">calc</span>(cur);</span><br><span class="line">        <span class="comment">// 如果新点距离更小，则跳到新点，否则以一定概率跳到新点。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>(-dt / t) &gt; <span class="built_in">rdd</span>(<span class="number">0</span>, <span class="number">1</span>)) cur = np;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 前置知识点</span><br><span class="line">    (<span class="number">1</span>) pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">    (<span class="number">2</span>) 余弦定理 c^<span class="number">2</span> = a^<span class="number">2</span> + b^<span class="number">2</span> - <span class="number">2</span>abcos(t)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 浮点数的比较</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sign</span><span class="params">(<span class="type">double</span> x)</span>  <span class="comment">// 符号函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>  <span class="comment">// 比较函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 向量</span><br><span class="line">    <span class="number">3.1</span> 向量的加减法和数乘运算</span><br><span class="line">    <span class="number">3.2</span> 内积（点积） A·B = |A||B|<span class="built_in">cos</span>(C)</span><br><span class="line">        (<span class="number">1</span>) 几何意义：向量A在向量B上的投影与B的长度的乘积。</span><br><span class="line">        (<span class="number">2</span>) 代码实现</span><br><span class="line">        <span class="type">double</span> <span class="built_in">dot</span>(Point a, Point b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="number">3.3</span> 外积（叉积） AxB = |A||B|<span class="built_in">sin</span>(C)</span><br><span class="line">        (<span class="number">1</span>) 几何意义：向量A与B张成的平行四边形的有向面积。B在A的逆时针方向为正。</span><br><span class="line">        (<span class="number">2</span>) 代码实现</span><br><span class="line">        <span class="type">double</span> <span class="built_in">cross</span>(Point a, Point b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a.x * b.y - b.x * a.y;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="number">3.4</span> 常用函数</span><br><span class="line">        <span class="number">3.4</span><span class="number">.1</span> 取模</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">get_length</span><span class="params">(Point a)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">dot</span>(a, a));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">3.4</span><span class="number">.2</span> 计算向量夹角</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">get_angle</span><span class="params">(Point a, Point b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">dot</span>(a, b) / <span class="built_in">get_length</span>(a) / <span class="built_in">get_length</span>(b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">3.4</span><span class="number">.3</span> 计算两个向量构成的平行四边形有向面积</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(Point a, Point b, Point c)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cross</span>(b - a, c - a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">3.4</span><span class="number">.5</span> 向量A顺时针旋转C的角度：</span><br><span class="line">        <span class="function">Point <span class="title">rotate</span><span class="params">(Point a, <span class="type">double</span> angle)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Point</span>(a.x * <span class="built_in">cos</span>(angle) + a.y * <span class="built_in">sin</span>(angle), -a.x * <span class="built_in">sin</span>(angle) + a.y * <span class="built_in">cos</span>(angle));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="number">4.</span> 点与线</span><br><span class="line">    <span class="number">4.1</span> 直线定理</span><br><span class="line">        (<span class="number">1</span>) 一般式 ax + by + c = <span class="number">0</span></span><br><span class="line">        (<span class="number">2</span>) 点向式 p0 + <span class="built_in">vt</span></span><br><span class="line">        (<span class="number">3</span>) 斜截式 y = kx + b</span><br><span class="line">    <span class="number">4.2</span> 常用操作</span><br><span class="line">        (<span class="number">1</span>) 判断点在直线上 A x B = <span class="number">0</span></span><br><span class="line">        (<span class="number">2</span>) 两直线相交</span><br><span class="line">        <span class="comment">// cross(v, w) == 0则两直线平行或者重合</span></span><br><span class="line">        Point <span class="built_in">get_line_intersection</span>(Point p, Vector v, Point q, vector w)</span><br><span class="line">        &#123;</span><br><span class="line">            vector u = p - q;</span><br><span class="line">            <span class="type">double</span> t = <span class="built_in">cross</span>(w, u) / <span class="built_in">cross</span>(v, w);</span><br><span class="line">            <span class="keyword">return</span> p + v * t;</span><br><span class="line">        &#125;</span><br><span class="line">        (<span class="number">3</span>) 点到直线的距离</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">distance_to_line</span><span class="params">(Point p, Point a, Point b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            vector v1 = b - a, v2 = p - a;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">cross</span>(v1, v2) / <span class="built_in">get_length</span>(v1));</span><br><span class="line">        &#125;</span><br><span class="line">        (<span class="number">4</span>) 点到线段的距离</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">distance_to_segment</span><span class="params">(Point p, Point a, Point b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="built_in">get_length</span>(p - a);</span><br><span class="line">            Vector v1 = b - a, v2 = p - a, v3 = p - b;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sign</span>(<span class="built_in">dot</span>(v1, v2)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">get_length</span>(v2);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sign</span>(<span class="built_in">dot</span>(v1, v3)) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">get_length</span>(v3);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">distance_to_line</span>(p, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        (<span class="number">5</span>) 点在直线上的投影</span><br><span class="line">        <span class="function">Point <span class="title">get_line_projection</span><span class="params">(Point p, Point a, Point b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Vector v = b - a;</span><br><span class="line">            <span class="keyword">return</span> a + v * (<span class="built_in">dot</span>(v, p - a) / <span class="built_in">dot</span>(v, v));</span><br><span class="line">        &#125;</span><br><span class="line">        (<span class="number">6</span>) 点是否在线段上</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">on_segment</span><span class="params">(Point p, Point a, Point b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sign</span>(<span class="built_in">cross</span>(p - a, p - b)) == <span class="number">0</span> &amp;&amp; <span class="built_in">sign</span>(<span class="built_in">dot</span>(p - a, p - b)) &lt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (<span class="number">7</span>) 判断两线段是否相交</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">segment_intersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">double</span> c1 = <span class="built_in">cross</span>(a2 - a1, b1 - a1), c2 = <span class="built_in">cross</span>(a2 - a1, b2 - a1);</span><br><span class="line">            <span class="type">double</span> c3 = <span class="built_in">cross</span>(b2 - b1, a2 - b1), c4 = <span class="built_in">cross</span>(b2 - b1, a1 - b1);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sign</span>(c1) * <span class="built_in">sign</span>(c2) &lt;= <span class="number">0</span> &amp;&amp; <span class="built_in">sign</span>(c3) * <span class="built_in">sign</span>(c4) &lt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="number">5.</span> 多边形</span><br><span class="line">    <span class="number">5.1</span> 三角形</span><br><span class="line">    <span class="number">5.1</span><span class="number">.1</span> 面积</span><br><span class="line">        (<span class="number">1</span>) 叉积</span><br><span class="line">        (<span class="number">2</span>) 海伦公式</span><br><span class="line">            p = (a + b + c) / <span class="number">2</span>;</span><br><span class="line">            S = <span class="built_in">sqrt</span>(<span class="built_in">p</span>(p - a) * (p - b) * (p - c));</span><br><span class="line">    <span class="number">5.1</span><span class="number">.2</span> 三角形四心</span><br><span class="line">        (<span class="number">1</span>) 外心，外接圆圆心</span><br><span class="line">            三边中垂线交点。到三角形三个顶点的距离相等</span><br><span class="line">        (<span class="number">2</span>) 内心，内切圆圆心</span><br><span class="line">            角平分线交点，到三边距离相等</span><br><span class="line">        (<span class="number">3</span>) 垂心</span><br><span class="line">            三条垂线交点</span><br><span class="line">        (<span class="number">4</span>) 重心</span><br><span class="line">            三条中线交点（到三角形三顶点距离的平方和最小的点，三角形内到三边距离之积最大的点）</span><br><span class="line">    <span class="number">5.2</span> 普通多边形</span><br><span class="line">        通常按逆时针存储所有点</span><br><span class="line">        <span class="number">5.2</span><span class="number">.1</span> 定义</span><br><span class="line">        (<span class="number">1</span>) 多边形</span><br><span class="line">            由在同一平面且不再同一直线上的多条线段首尾顺次连接且不相交所组成的图形叫多边形</span><br><span class="line">        (<span class="number">2</span>) 简单多边形</span><br><span class="line">            简单多边形是除相邻边外其它边不相交的多边形</span><br><span class="line">        (<span class="number">3</span>) 凸多边形</span><br><span class="line">            过多边形的任意一边做一条直线，如果其他各个顶点都在这条直线的同侧，则把这个多边形叫做凸多边形</span><br><span class="line">            任意凸多边形外角和均为<span class="number">360</span>°</span><br><span class="line">            任意凸多边形内角和为(n−<span class="number">2</span>)<span class="number">180</span>°</span><br><span class="line">        <span class="number">5.2</span><span class="number">.2</span> 常用函数</span><br><span class="line">        (<span class="number">1</span>) 求多边形面积（不一定是凸多边形）</span><br><span class="line">        我们可以从第一个顶点除法把凸多边形分成n − <span class="number">2</span>个三角形，然后把面积加起来。</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">polygon_area</span><span class="params">(Point p[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt; n; i ++ )</span><br><span class="line">                s += <span class="built_in">cross</span>(p[i] - p[<span class="number">0</span>], p[i + <span class="number">1</span>] - p[i]);</span><br><span class="line">            <span class="keyword">return</span> s / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (<span class="number">2</span>) 判断点是否在多边形内（不一定是凸多边形）</span><br><span class="line">        a. 射线法，从该点任意做一条和所有边都不平行的射线。交点个数为偶数，则在多边形外，为奇数，则在多边形内。</span><br><span class="line">        b. 转角法</span><br><span class="line">        (<span class="number">3</span>) 判断点是否在凸多边形内</span><br><span class="line">        只需判断点是否在所有边的左边（逆时针存储多边形）。</span><br><span class="line">    <span class="number">5.3</span> 皮克定理</span><br><span class="line">        皮克定理是指一个计算点阵中顶点在格点上的多边形面积公式该公式可以表示为:</span><br><span class="line">            S = a + b/<span class="number">2</span> - <span class="number">1</span></span><br><span class="line">        其中a表示多边形内部的点数，b表示多边形边界上的点数，S表示多边形的面积。</span><br><span class="line"><span class="number">6.</span> 圆</span><br><span class="line">    (<span class="number">1</span>) 圆与直线交点</span><br><span class="line">    (<span class="number">2</span>) 两圆交点</span><br><span class="line">    (<span class="number">3</span>) 点到圆的切线</span><br><span class="line">    (<span class="number">4</span>) 两圆公切线</span><br><span class="line">    (<span class="number">5</span>) 两圆相交面积</span><br><span class="line"></span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/635453/</span></span><br><span class="line">来源：AcWing</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://pic.arctanp.top/PicGo/avator" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://pic.arctanp.top/PicGo/avator" title="头像" alt="头像"></a><div class="post-copyright__author_name">Lightmon</div><div class="post-copyright__author_desc">tanps blog</div></div><div class="post-copyright__post__info"><a class="post-copyright__reprint" title="该文章为转载文章，注意版权协议" target="_blank" rel="noopener" href="https://www.cnblogs.com/lightmon5210/p/18183718">转载</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://www.cnblogs.com/lightmon5210/p/18183718')">（转载）cpp算法模板</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://www.cnblogs.com/lightmon5210/p/18183718"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=（转载）cpp算法模板&amp;url=https://www.cnblogs.com/lightmon5210/p/18183718&amp;pic=https://pic.arctanp.top/PicGo/1742042046711.jpeg?_r_=0fe43d33-1d26-f270-676a-a3edd0e011f3" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">此文章版权归Lightmon所有，如有转载，请注明来自原作者</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>算法<span class="tagsPageCount">3</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://pic.arctanp.top/PicGo/1742042046711.jpeg?_r_=0fe43d33-1d26-f270-676a-a3edd0e011f3" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/03/19/C%E5%8E%9F%E7%94%9F%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E8%B5%8B%E5%80%BC%E5%BC%95%E8%B5%B7%E7%9A%84%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F/" title="[C&#x2F;C++]原生数组不可赋值引起的编译错误该如何解决？"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://pic.arctanp.top/PicGo/87f4053febb8101cae0bcfa88d9338ca9a834e1b_raw.jpg?_r_=6deda904-8c8e-e116-de1d-bd6fe8ee8c88" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-19</div><div class="title">[C&#x2F;C++]原生数组不可赋值引起的编译错误该如何解决？</div></div></a></div><div><a href="/2025/01/25/%E6%9D%AD%E7%94%B5acm%E5%85%A5%E9%97%A8/" title="杭电acm入门"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://pic.arctanp.top/PicGo/a907667fd986a8ddc4dcab3a69fb8092.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-01-25</div><div class="title">杭电acm入门</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://pic.arctanp.top/PicGo/avator" onerror="this.onerror=null;this.src='/null'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://emotion.acs.pw/emotion/QQ/101.gif" alt="status"/></div></div><div class="author-info__description">摸了</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">Tanpinsary</h1><div class="author-info__desc">tanps blog</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/Tanpinsary" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/391553043" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">blog建设ing 半成品</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.</span> <span class="toc-text">C++算法模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">归并排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">二分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">整数二分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">浮点数二分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">高精度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">高精度加法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">高精度减法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E4%BD%8E%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">高精度乘低精度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E4%BB%A5%E4%BD%8E%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">高精度除以低精度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">1.1.4.</span> <span class="toc-text">离散化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BA%E5%8F%96%E6%B3%95%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">尺取法（双指针）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA%E4%B8%8E%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86"><span class="toc-number">1.2.</span> <span class="toc-text">数论与数学知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E6%B1%82%E4%B8%8A%E5%8F%96%E6%95%B4"><span class="toc-number">1.2.1.</span> <span class="toc-text">c++求上取整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">1.2.2.</span> <span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%85%83"><span class="toc-number">1.2.3.</span> <span class="toc-text">逆元</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E6%B1%82%E9%80%86%E5%85%83"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">费马小定理求逆元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">快速幂求逆元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E9%80%86%E5%85%83"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">线性逆元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">扩展欧几里得算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95"><span class="toc-number">1.2.5.</span> <span class="toc-text">高斯消元法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%9B%E8%B4%A8%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">筛质数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%AD%9B%E6%B3%95"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">朴素筛法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A8%E6%95%B0%E5%AE%9A%E7%90%86"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">质数定理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">埃氏筛法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">线性筛法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.7.</span> <span class="toc-text">欧拉函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">筛法求欧拉函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0"><span class="toc-number">1.2.8.</span> <span class="toc-text">组合数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B01"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">组合数1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B02"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">组合数2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%9A%E5%BC%88%E8%AE%BA"><span class="toc-number">1.2.9.</span> <span class="toc-text">博弈论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SG%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">SG函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.3.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF-%E6%9C%B4%E7%B4%A0%E7%89%88"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Dijkstra求最短路(朴素版)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E4%BC%98%E5%8C%96%E7%9A%84Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">堆优化的Dijkstra算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPFA"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">SPFA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.3.2.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">kruskal算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LCA-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">1.3.3.</span> <span class="toc-text">LCA(最近公共祖先)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs%E7%89%88%E6%9C%AC%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">dfs版本预处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF"><span class="toc-number">1.3.4.</span> <span class="toc-text">欧拉路径与欧拉回路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">dfs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fleury"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">fleury</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88%E9%9D%99%E6%80%81%EF%BC%89"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">单链表（静态）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">双链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">一般队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">循环队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">单调队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.4.3.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%A0%88"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">一般栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">表达式求值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">单调栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP"><span class="toc-number">1.4.4.</span> <span class="toc-text">KMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TRIE"><span class="toc-number">1.4.5.</span> <span class="toc-text">TRIE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.4.6.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.4.7.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.4.8.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%89%E9%93%BE%E6%B3%95"><span class="toc-number">1.4.8.1.1.</span> <span class="toc-text">拉链法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"><span class="toc-number">1.4.8.1.2.</span> <span class="toc-text">开放寻址法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.4.9.</span> <span class="toc-text">树状数组和线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.9.1.</span> <span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.4.9.2.</span> <span class="toc-text">线段树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%EF%BC%88%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86%EF%BC%89"><span class="toc-number">1.4.10.</span> <span class="toc-text">树链剖分（重链剖分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6"><span class="toc-number">1.4.11.</span> <span class="toc-text">树上启发式合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%AB%E9%98%9F"><span class="toc-number">1.4.12.</span> <span class="toc-text">莫队</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%8E%AB%E9%98%9F"><span class="toc-number">1.4.12.1.</span> <span class="toc-text">基础莫队</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%84%E5%AD%A6%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.12.1.1.</span> <span class="toc-text">玄学优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%A1%B6%E5%A0%86"><span class="toc-number">1.4.13.</span> <span class="toc-text">对顶堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8Cset%E7%89%88%E6%9C%AC"><span class="toc-number">1.4.13.1.</span> <span class="toc-text">双set版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%B8%A6%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%89%88"><span class="toc-number">1.4.13.2.</span> <span class="toc-text">堆带删除操作版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E4%BB%85%E6%8F%92%E5%85%A5%E7%89%88"><span class="toc-number">1.4.13.3.</span> <span class="toc-text">堆仅插入版</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89"><span class="toc-number">1.4.14.</span> <span class="toc-text">主席树（可持久化权值线段树）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.5.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.5.1.</span> <span class="toc-text">最长上升子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.2.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">01背包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%8C%E7%BB%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text">01背包问题的二维代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85%E4%B8%80%E7%BB%B4%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.1.2.</span> <span class="toc-text">01背包一维优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">完全背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%89%E9%87%8D%E5%BE%AA%E7%8E%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">完全背包问题的三重循环代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E9%87%8D%E5%BE%AA%E7%8E%AF%E4%BA%8C%E7%BB%B4%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.2.2.2.</span> <span class="toc-text">二重循环二维的优化过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%B8%80%E7%BB%B4%E6%9C%80%E7%BB%88%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.2.3.</span> <span class="toc-text">完全背包一维最终优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%851"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">多重背包1</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%89%E9%87%8D%E5%BE%AA%E7%8E%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.2.3.1.</span> <span class="toc-text">多重背包问题的三重循环代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%80%E7%BB%B4%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.2.3.2.</span> <span class="toc-text">多重背包问题一维优化代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%89%93%E5%8C%85%E7%89%88"><span class="toc-number">1.5.2.3.3.</span> <span class="toc-text">多重背包问题打包版</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.2.3.4.</span> <span class="toc-text">多重背包单调队列优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">分组背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%80%E7%BB%B4%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.2.4.1.</span> <span class="toc-text">分组背包问题一维优化代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%AD%E6%80%BB%E4%BD%93%E7%A7%AF%E6%9C%80%E5%A4%9A-%E6%81%B0%E5%A5%BD-%E6%9C%80%E5%B0%91%E4%B8%BAj-%E4%BB%A5%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC%E4%B8%BA%E4%BE%8B-3%E6%98%AF%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">背包问题中总体积最多&#x2F;恰好&#x2F;最少为j, 以求最大值为例(3是最小值)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%BE%9D%E8%B5%96%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">有依赖的背包问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">混合背包问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">随机算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB"><span class="toc-number">1.6.1.</span> <span class="toc-text">模拟退火</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95"><span class="toc-number">1.7.</span> <span class="toc-text">计算几何</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.7.1.</span> <span class="toc-text">前置知识</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/21/%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89cpp%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="（转载）cpp算法模板"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://pic.arctanp.top/PicGo/1742042046711.jpeg?_r_=0fe43d33-1d26-f270-676a-a3edd0e011f3" onerror="this.onerror=null;this.src='/null'" alt="（转载）cpp算法模板"/></a><div class="content"><a class="title" href="/2025/03/21/%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89cpp%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/" title="（转载）cpp算法模板">（转载）cpp算法模板</a><time datetime="2025-03-21T02:32:50.000Z" title="发表于 2025-03-21 10:32:50">2025-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/19/C%E5%8E%9F%E7%94%9F%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E8%B5%8B%E5%80%BC%E5%BC%95%E8%B5%B7%E7%9A%84%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F/" title="[C/C++]原生数组不可赋值引起的编译错误该如何解决？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://pic.arctanp.top/PicGo/87f4053febb8101cae0bcfa88d9338ca9a834e1b_raw.jpg?_r_=6deda904-8c8e-e116-de1d-bd6fe8ee8c88" onerror="this.onerror=null;this.src='/null'" alt="[C/C++]原生数组不可赋值引起的编译错误该如何解决？"/></a><div class="content"><a class="title" href="/2025/03/19/C%E5%8E%9F%E7%94%9F%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E8%B5%8B%E5%80%BC%E5%BC%95%E8%B5%B7%E7%9A%84%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F/" title="[C/C++]原生数组不可赋值引起的编译错误该如何解决？">[C/C++]原生数组不可赋值引起的编译错误该如何解决？</a><time datetime="2025-03-19T05:58:41.000Z" title="发表于 2025-03-19 13:58:41">2025-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/13/%E6%97%A5%E5%AF%84%E5%85%B6%E4%B8%80/" title="日寄其一"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://pic.arctanp.top/PicGo/9a00e075ac0b436a9076e5d66389d94d.jpg" onerror="this.onerror=null;this.src='/null'" alt="日寄其一"/></a><div class="content"><a class="title" href="/2025/03/13/%E6%97%A5%E5%AF%84%E5%85%B6%E4%B8%80/" title="日寄其一">日寄其一</a><time datetime="2025-03-13T14:57:22.000Z" title="发表于 2025-03-13 22:57:22">2025-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/10/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学学习笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://pic.arctanp.top/PicGo/fd091cd91f51f662709b5efe4c5cc20af046679c_raw.jpg" onerror="this.onerror=null;this.src='/null'" alt="离散数学学习笔记"/></a><div class="content"><a class="title" href="/2025/03/10/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学学习笔记">离散数学学习笔记</a><time datetime="2025-03-10T05:09:00.000Z" title="发表于 2025-03-10 13:09:00">2025-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/03/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="大学物理D学习笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;null&quot;" data-lazy-src="https://pic.arctanp.top/PicGo/09004ece38453ecc7dd8b3915a9513fbf4b2cab9_raw.jpg" onerror="this.onerror=null;this.src='/null'" alt="大学物理D学习笔记"/></a><div class="content"><a class="title" href="/2025/03/03/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="大学物理D学习笔记">大学物理D学习笔记</a><time datetime="2025-03-03T01:57:00.000Z" title="发表于 2025-03-03 09:57:00">2025-03-03</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="Tanpinsary" target="_blank">Tanpinsary</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://pic.arctanp.top" title="图床">图床</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">11</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.arctanp.top" title="博客"><img class="back-menu-item-icon" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://pic.arctanp.top" title="图床"><img class="back-menu-item-icon" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-link"></use></svg><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2024775299&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lightbulb"></use></svg><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C-C/" style="font-size: 0.88rem;">C/C++<sup>1</sup></a><a href="/tags/acm/" style="font-size: 0.88rem;">acm<sup>1</sup></a><a href="/tags/deepseek-r1/" style="font-size: 0.88rem;">deepseek-r1<sup>1</sup></a><a href="/tags/insights/" style="font-size: 0.88rem;">insights<sup>1</sup></a><a href="/tags/llm/" style="font-size: 0.88rem;">llm<sup>1</sup></a><a href="/tags/markdown/" style="font-size: 0.88rem;">markdown<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">复习笔记<sup>3</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">学习笔记<sup>4</sup></a><a href="/tags/%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">实践笔记<sup>1</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>4</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/" style="font-size: 0.88rem;">数学分析<sup>2</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 0.88rem;">测试<sup>1</sup></a><a href="/tags/%E7%89%A9%E7%90%86/" style="font-size: 0.88rem;">物理<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>3</sup></a><a href="/tags/%E8%AF%AD%E6%B3%95/" style="font-size: 0.88rem;">语法<sup>1</sup></a><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 0.88rem;">随笔<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=2024775299&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="https://cdn.cbd.int/hexo-theme-anzhiyu@1.6.14/source/js/utils.js"></script><script src="https://cdn.cbd.int/hexo-theme-anzhiyu@1.6.14/source/js/main.js"></script><script src="https://cdn.cbd.int/hexo-theme-anzhiyu@1.6.14/source/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("01/13/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Tanpinsary 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("01/13/2025 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "摸了";
        img.alt = "摸了";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>